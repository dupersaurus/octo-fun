<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":"# ######################################\n# JEFF QUEST\n#  Octo + clip at edges\n#  100/sec\n#  BG   #000\n#  FG1  #F0F\n#  FG2  #0FF\n#  Bnd  #FFF\n#  Bzz  #909\n#  Sil\t#222\n# ######################################\n\n:alias viewer-count\t\tv5\t# viewer count in the current order, [0-99]\n:alias viewer-order\t\tv6\t# one tick for every 100 viewers\n:alias viewer-rollover\tv7\t# incremental viewer step\n:alias game-state  v8\n\n:alias px\t\t\t\tva\n:alias py\t\t\t\tvb\n:alias direction\t\tvc \t# direction wind comes from\n:alias next-spawn\t\tvd\n\n# ### stuff that's safe to use for multiple things ###\n:alias x\t\t\t\tv1\n:alias y\t\t\t\tv2\n:alias wind-force\t\tv3\n\n:alias debris-data\t\tv1\n:alias debrisX\t\t\tv2\n:alias debrisY\t\t\tv3\n:alias debrisAccumulate\tv4\n\n:const STATE_TITLE\t\t1\n:const STATE_GAME\t\t2\n:const STATE_DEAD\t\t3\n:const STATE_END\t\t4\n\n:const MASK_DEBRIS_ALIVE \t 0b00000001\n:const MASK_DEBRIS_DEAD  \t 0b11111110\n:const MASK_DEBRIS_TYPE  \t 0b00000110\n:const MASK_DEBRIS_SET_TYPE  0b11111001\n:const MASK_DEBRIS_DIR_Y\t 0b00001000\n:const MASK_DEBRIS_SET_DIR_Y 0b11110111\n\n:macro get-debris-alive target temp {\n\ttarget := debris-data\n\ttemp := MASK_DEBRIS_ALIVE\n\ttarget &= temp\n}\n\n:macro set-debris-alive temp {\n\ttemp := MASK_DEBRIS_ALIVE\n\tdebris-data |= temp\n}\n\n:macro set-debris-dead temp {\n\ttemp := MASK_DEBRIS_DEAD\n\tdebris-data &= temp\n}\n\n:macro get-debris-type target temp {\n\ttarget := debris-data\n\ttemp := MASK_DEBRIS_TYPE\n\ttarget &= temp\n\ttarget >>= target\n}\n\n:macro set-debris-type type temp {\n\ttemp := MASK_DEBRIS_SET_TYPE\n\tdebris-data &= temp\n\ttemp := type\n\ttemp <<= temp\n\tdebris-data |= temp\n}\n\n:macro get-debris-direction target temp {\n\ttarget := debris-data\n\ttemp := MASK_DEBRIS_DIR_Y\n\ttarget &= temp\n\ttarget >>= target\n\ttarget >>= target\n\ttarget >>= target\n}\n\n:macro set-debris-direction dir temp {\n\ttemp := MASK_DEBRIS_SET_DIR_Y\n\tdebris-data &= temp\n\ttemp := dir\n\ttemp <<= temp\n\ttemp <<= temp\n\ttemp <<= temp\n\tdebris-data |= temp\n}\n\n# check collision with the shed at a point and jump to out if no collision\n:macro check-shed-collision tx ty out {\n\tif tx < SHED_LEFT_JEFF \tthen jump out\n\tif tx > SHED_RIGHT\t\tthen jump out\n\tif ty <= SHED_TOP_JEFF\tthen jump out\n\tif ty >= SHED_BOTTOM\tthen jump out\n}\n\n:macro check-jeff-collision x y temp out {\n\tget-jeff-right temp\n\tif x > temp\tthen jump out\n\n\ttemp := x\n\ttemp += 7\n\tif temp < px then jump out\n\n\ttemp := y\n\ttemp += 5\n\tif temp < py then jump out\n\n\tget-jeff-bottom temp\n\tif y > temp\tthen jump out\n}\n\n# #########\n:const WIND_NORTH\t\t0\n:const WIND_EAST\t\t1\n:const WIND_SOUTH\t\t2\n:const WIND_WEST\t\t3\n\n:const SHED_LEFT\t\t56\n:const SHED_TOP\t\t\t24\n:const SHED_RIGHT\t\t72\n:const SHED_BOTTOM\t\t40\n\n# the left and top bounds of the shed from the perspective of jeff\n:const SHED_LEFT_JEFF\t52\t\n:const SHED_TOP_JEFF\t16\n:const SHED_BOTTOM_JEFF\t30\n\n:macro get-jeff-right out {\n\tout := px\n\tout += 5\n}\n\n:macro get-jeff-bottom out {\n\tout := py\n\tout += 10\n}\n\n:const DEBRIS_SPAWN_X\t120\n\n: main\n\tgoto-title\n\n\tloop\n\t\tif game-state == STATE_TITLE then title-screen\n\t\tif game-state == STATE_GAME then game-loop\n\t\tif game-state == STATE_DEAD then blow-jeff-away\n\t\tif game-state == STATE_END then final-score\n\tagain\n;\n\n: goto-title\n\tgame-state := STATE_TITLE\n;\n\n: goto-game\n\tgame-state := STATE_GAME\n;\n\n: goto-dead\n\tgame-state := STATE_DEAD\n;\n\n: goto-end\n\tgame-state := STATE_END\n;\n\n## MEMORY ####################################################################\n: debris \n0\t# data\n0\t# x\n0\t# y\n0 \t# accumulator\n\n## GAME STATES ###############################################################\n: title-screen\n\tclear\n\tlores\n\n\tx := 11\n\ty := 5\n\tplane 2\n\n\ti := title-jeffJ\n\tsprite x y 15\n\n\tx += 8\n\ti := title-jeffE\n\tsprite x y 7\n\n\tx += 6\n\ti := title-jeffF\n\tsprite x y 9\n\n\tx += 6\n\ti := title-jeffF\n\tsprite x y 9\n\n\ti := title-questQ\n\tx := 20\n\ty := 16\n\tsprite x y 13\n\n\tx += 8\n\ti := title-questU\n\tsprite x y 7\n\n\tx += 7\n\ti := title-jeffE\n\tsprite x y 7\n\n\tx += 6\n\ti := title-questS\n\tsprite x y 8\n\n\tx += 7\n\ti := title-questT\n\tsprite x y 10\n\n\tv0 := key\n\tgame-loop\n;\n\n: game-loop\n\thires\n\n\tpx := SHED_LEFT_JEFF\n\tpy := SHED_TOP\n\tpx += -2\n\n\tdirection := WIND_EAST\n\tnext-spawn := 0\n\n\tviewer-count := 0\n\tviewer-order := 0\n\tviewer-rollover := 0\n\n\tdraw-shed\n\tdraw-jeff\n\tdraw-viewers\n\n\tloop\n\t\tupdate-debris\n\t\tread-input\n\t\tupdate-viewers\n\n\t\tif game-state == 1 then\n\tagain\n;\n\n: blow-jeff-away\n\tdraw-jeff-flying\n\tx := 0\n\n\tloop\n\t\ty := 25\n\t\tx += y\n\t\t\n\t\tif vf == 1 begin \n\t\t\tdraw-jeff-flying\n\t\t\tpx += -1\n\t\t\tdraw-jeff-flying\n\t\tend\n\n\t\tif px != 0 then \n\tagain\n\n\tgoto-end\n;\n\n: final-score\n\tplane 3\n\tclear\n\tdraw-viewers\n\n\tplane 3\n\n\ti := gosh-g\n\tx := 28\n\ty := 24\n\tsprite x y 0\n\n\ti := gosh-o\n\tx := 44\n\ty := 22\n\tsprite x y 0\n\n\ti := gosh-s\n\tx := 60\n\ty := 26\n\tsprite x y 0\n\n\ti := gosh-h\n\tx := 74\n\ty := 23\n\tsprite x y 0\n\n\ti := gosh-bang\n\tx := 90\n\ty := 25\n\tsprite x y 15\n\n\tv0 := key\n\tgoto-title\n;\n\n## THE MEAT    ###############################################################\n: read-input\n\tv0 := 0x5\n\tif v0 key then jump move-up\n\n\tv0 := 0x7\n\tif v0 key then jump move-left\n\n\tv0 := 0x8\n\tif v0 key then jump move-down\n\n\tv0 := 0x9\n\tif v0 key then jump move-right\n;\n\n: set-jeff-position\n\tdraw-jeff\n\tpx := x\n\tpy := y\n\tdraw-jeff\n;\n\n: move-left\n\ty := py\n\tx := px\n\tx += -1\n\tif x == 255 then x := 0\n\n\tif x == px then return\n\n\tcheck-shed-collision x y set-jeff-position\n;\n\n: move-right\n\ty := py\n\tx := px\n\tx += 1\n\tif x == 124 then x := 123\n\n\tif x == px then return\n\n\tcheck-shed-collision x y set-jeff-position\n;\n\n: move-up\n\tx := px\n\ty := py\n\ty += -1\n\tif y == 255 then y := 0\n\n\tif y == py then return\n\n\tcheck-shed-collision x y set-jeff-position\n;\n\n: move-down\n\tx := px\n\ty := py\n\ty += 1\n\tif y == 55 then y := 54\n\n\tif y == py then return\n\n\tcheck-shed-collision x y set-jeff-position\n;\n\n# update the viewer count\n: update-viewers\n\tget-wind-force\n\tv4 := 10\n\n\tif wind-force != 0 begin \n\t\tviewer-rollover += wind-force\n\t\t\n\t\tif vf == 1 begin\n\t\t\tdraw-viewers\n\t\t\tviewer-count += 1\n\t\t\tset-new-viewer-count\n\t\tend \n\telse\n\t\tviewer-rollover -= v4\n\n\t\tif vf == 0 begin\n\t\t\tdraw-viewers\n\n\t\t\tv4 := 1\n\t\t\tviewer-count -= v4\n\n\t\t\tif vf == 0 then viewer-count := 0\n\t\t\tset-new-viewer-count\n\t\tend\n\tend\n;\n\n: set-new-viewer-count\n\tif viewer-count == 100 begin\n\t\tviewer-count := 10\n\t\tviewer-order += 1\n\tend\n\tdraw-viewers\n;\n\n# calculate the force of the wind and save to v3\n: get-wind-force\n\tif direction == WIND_NORTH\tthen jump calculate-north-wind-force\n\tif direction == WIND_EAST\tthen jump calculate-east-wind-force\n\tif direction == WIND_SOUTH\tthen jump calculate-south-wind-force\n\tif direction == WIND_WEST\tthen jump calculate-west-wind-force\n;\n\n: calculate-north-wind-force\n\n;\n\n: calculate-east-wind-force\n\tv4 := 0\n\t\n\tif py < SHED_TOP begin \n\t\tv3 := SHED_TOP\n\t\tv4 := py\n\t\tv4 =- v3\n\tend\n\n\tif py > SHED_BOTTOM_JEFF begin \n\t\tv3 := SHED_BOTTOM_JEFF\n\t\tv4 := py\n\t\tv4 -= v3\n\tend\n\n\tif px > SHED_LEFT_JEFF begin\n\t\tv3 := px\n\t\tv3 -= SHED_LEFT_JEFF\n\n\t\tv4 += v3\n\t\tv4 += v3\n\tend\n\n\tcalculate-force\n\twind-force := v4\n;\n\n: calculate-south-wind-force\n\n;\n\n: calculate-west-wind-force\n\n;\n\n# calculate the resulting force from how uncovered jeff is, set in v4\n: calculate-force\n\t#if v4 == 0 then return\n;\n\n: update-debris\n\ti := debris\n\tload debris-data - debrisAccumulate\n\n\tget-debris-alive ve v0\n\tif ve == 0 then jump check-spawn-debris\n\n\tmove-debris\n;\n\n: check-spawn-debris\n\tif next-spawn == 0 then jump spawn-debris\n\tnext-spawn -= 1\n;\n\n: spawn-debris\n\tdebris-data := 0b00000001\n\tdebrisX := random 1\n\n\tset-debris-type debrisX debrisY\n\n\tdebrisX := DEBRIS_SPAWN_X\n\tdebrisY := random 10\n\tdebrisY += -5\n\tdebrisY += py\n\n\t#if vf == 1 then debrisY := 0\n\t#if debrisY > 56 then debrisY := 56\n\n\tdebrisAccumulate := 0\n\n\tsave-debris\n\tdraw-debris\n;\n\n: draw-debris\n\tget-debris-type ve v0\n\tv0 := 32\n\ti := debris-sprites\n\n\tloop\n\t\twhile ve != 0\n\t\ti += v0\n\t\tve += -1\n\tagain\n\n\tplane 3\n\tsprite debrisX debrisY 15\n;\n\n: move-debris\n\tif debrisX == 0 then jump kill-debris\n\n\tv0 := 200\n\tdebrisAccumulate += v0\n\t\n\tif vf == 1 then jump check-debris-against-jeff\n\tsave-debris\n;\n\n: check-debris-against-shed\n\tcheck-shed-collision debrisX debrisY check-debris-against-jeff\n\tkill-debris\n;\n\n: check-debris-against-jeff\n\tcheck-jeff-collision debrisX debrisY v0 do-move-debris\n\tkill-jeff\n;\n\n: do-move-debris\n\tdraw-debris\n\n\tget-debris-type v0 ve\n\tv0 <<= v0\n\tjump0 move-debris-type-jump\n;\n\n: move-debris-type-jump\n\tjump move-debris-board\n\tjump move-debris-tire\n;\n\n: move-debris-board\n\tdebrisX += -1\n\tfinalize-step-debris\n;\n\n: move-debris-tire\n\tdebrisX += -1\n\tget-debris-direction v0 ve\n\n\tve := random 150\n\t#:breakpoint is-ve-0\n\tif ve == 0 then reverse-y-direction \n\n\tif v0 == 0 then jump move-debris-down\n\tif v0 == 1 then jump move-debris-up\n;\n\n# requires v0 to be the current direction\n: reverse-y-direction\n\tif v0 == 0 begin \n\t\tset-debris-direction 1 ve\n\telse\n\t\tset-debris-direction 0 ve\n\tend\n;\n\n: move-debris-up\n\tdebrisY += -1\n\tif debrisY > 64 begin \n\t\tdebrisY := 0\n\t\tset-debris-direction 0 v0\n\tend\n\n\tfinalize-step-debris\n;\n\n: move-debris-down\n\tdebrisY += 1\n\tif debrisY > 58 begin \n\t\tdebrisY := 58\n\t\tset-debris-direction 1 v0\n\tend\n\n\tfinalize-step-debris\n;\n\n: finalize-step-debris\n\tdraw-debris\n\tsave-debris\n;\n\n: save-debris\n\ti := debris\n\tsave debris-data - debrisAccumulate\n;\n\n: kill-debris \n\tset-debris-dead v0\n\tnext-spawn := random 30\n\tnext-spawn += 10\n\tdraw-debris\n\tsave-debris\n;\n\n: kill-jeff\n\tkill-debris\n\tdraw-jeff\n\tgoto-dead\n;\n\n: draw-shed\n\tx := SHED_LEFT\n\ty := SHED_TOP\n\ti := shed\n\n\tplane 2\n\tsprite x y 0\n;\n\n: draw-jeff\n\ti := jeff-left\n\tplane 2\n\tsprite px py 10\n\n\tif direction == WIND_EAST begin\n\t\tv0 := px\n\t\tget-wind-force\n\t\tv0 -= wind-force\n\n\t\tif vf == 0 then v0 := 0\n\n\t\tplane 1\n\t\tsprite v0 py 10\n\tend\n;\n\n: draw-jeff-flying\n\ti := jeff-flying\n\tplane 2\n\tsprite px py 10\n;\n\n: draw-viewers\n\tplane 1\n\tx := 1\n\ty := 53\n\ti := viewer\n\tsprite x y 10\n\n\tdraw-viewer-digits\n;\n\n: draw-viewer-digits\n\ti := digits\n\tbcd viewer-count\n\tload v2\n\n\tv4 := 12\n\tv9 := 58\n\n\ti := hex v1\n\tsprite v4 v9 5\n\n\ti := hex v2\n\tv4 += 5\n\tsprite v4 v9 5\n\n\t# draw the order\n\tv0 := 0\n\tv1 := 0\n\tloop\n\t\twhile v0 != viewer-order\n\n\t\tv4 += 5\n\t\ti := hex v1\n\t\tsprite v4 v9 5\n\n\t\tv0 += 1\n\tagain\n;\n\n: digits 0 0 0\n\n: shed\n0x00 0x00 0x00 0x00 0x01 0xF8 0x07 0xFC \n0x0F 0xFA 0x11 0xF7 0x20 0xEF 0x40 0x5F \n0x80 0x3F 0x80 0x3F 0x80 0x3F 0x80 0x3E \n0x80 0x3C 0x80 0x38 0x80 0x30 0xFF 0xE0\n\n: debris-sprites\n0x03 0x07 0x1E 0x78 0xE0 0xC0 0x00 0x00 # board\n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x03 \n0x07 0x1E 0x78 0xE0 0xC0 0x00 0x00 0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n0x38 0x5C 0xB6 0xB6 0x5C 0x38 0x00 0x00 # tire \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x38 \n0x5C 0xB6 0xB6 0x5C 0x38 0x00 0x00 0x00 \n0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n\n: jeff-left\t\t0x20 0x50 0x50 0xA0 0xF0 0x28 0x20 0x50 0x50 0x50\n: jeff-right\t0x20 0x50 0x50 0x28 0x78 0xA0 0x20 0x50 0x50 0x50\n: jeff-flying   0x20 0x50 0x50 0xA4 0x78 0x16 0x08 0x06 0x00 0x00\n: viewer\t\t0x7E 0x81 0xA5 0x81 0x42 0x3C 0x7E 0xFF 0xFF 0xFF\n\n: title-jeffJ\t0xC0 0xFE 0x7F 0x0F 0x06 0x06 0x02 0x02 0x02 0x02 0x06 0xC6 0xCE 0xFC 0x78 \n: title-jeffE\t0x78 0xD8 0x88 0xF0 0x84 0xFC 0x78\n: title-jeffF\t0x3C 0x7E 0x62 0x60 0xF0 0x78 0x6C 0x60 0xE0\n: title-questQ\t0x1C 0x32 0x61 0xC1 0x81 0x81 0x81 0x83 0x97 0x8E 0x5C 0x32 0x01 \n: title-questU\t0xCE 0x84 0x84 0x84 0xCC 0x7C 0x38\n: title-questS\t0x3C 0x66 0x62 0x30 0x18 0x8C 0xCC 0x78\n: title-questT\t0x18 0x38 0x30 0xF0 0x78 0x3C 0x30 0xB0 0xF0 0x60\n\n: gosh-g\n0x00 0x00 0x07 0xE0 0x1E 0x38 0x3C 0x0C 0x38 0x00 0x78 0x00 0x70 0x00 0xF0 0x00 0xE0 0x7C 0xE1 0xFC 0xE1 0xCE 0xF1 0x8E 0x70 0x07 0x3C 0x07 0x1F 0x0E 0x07 0xFC 0x00 0x00 0x07 0xE0 0x1E 0x38 0x3C 0x0C 0x38 0x00 0x78 0x00 0x70 0x00 0xF0 0x00 0xE0 0x7C 0xE1 0xFC 0xE1 0xCE 0xF1 0x8E 0x70 0x07 0x3C 0x07 0x1F 0x0E 0x07 0xFC\n\n: gosh-o\n0x00 0x00 0x07 0xE0 0x1E 0x78 0x3C 0x1C 0x38 0x0E 0x78 0x06 0x70 0x06 0xF0 0x03 0xE0 0x03 0xE0 0x03 0xE0 0x03 0xF0 0x03 0x70 0x07 0x3C 0x07 0x1F 0x0E 0x07 0xFC 0x00 0x00 0x07 0xE0 0x1E 0x78 0x3C 0x1C 0x38 0x0E 0x78 0x06 0x70 0x06 0xF0 0x03 0xE0 0x03 0xE0 0x03 0xE0 0x03 0xF0 0x03 0x70 0x07 0x3C 0x07 0x1F 0x0E 0x07 0xFC\n\n: gosh-s\n0x07 0x80 0x0C 0xF0 0x18 0x1C 0x10 0x04 0x10 0x04 0x10 0x04 0x10 0x00 0x19 0xF0 0x0F 0xFC 0x03 0xFE 0x20 0x0E 0x60 0x0E 0x78 0x0E 0x7F 0x1E 0x3F 0xFC 0x3F 0xF0 0x07 0x80 0x0C 0xF0 0x18 0x1C 0x10 0x04 0x10 0x04 0x10 0x04 0x10 0x00 0x19 0xF0 0x0F 0xFC 0x03 0xFE 0x20 0x0E 0x60 0x0E 0x78 0x0E 0x7F 0x1E 0x3F 0xFC 0x3F 0xF0\n\n: gosh-h\n0x78 0x1E 0x70 0x0C 0x30 0x0C 0x38 0x0C 0x18 0x0C 0x18 0x18 0x19 0xF8 0x0F 0xF8 0x0F 0xCC 0x0F 0x0C 0x0C 0x0C 0x0C 0x0E 0x08 0x06 0x18 0x07 0x1C 0x07 0x3C 0x06 0x78 0x1E 0x70 0x0C 0x30 0x0C 0x38 0x0C 0x18 0x0C 0x18 0x18 0x19 0xF8 0x0F 0xF8 0x0F 0xCC 0x0F 0x0C 0x0C 0x0C 0x0C 0x0E 0x08 0x06 0x18 0x07 0x1C 0x07 0x3C 0x06\n\n: gosh-bang\n0x1C 0x7C 0x7C 0x7C 0x3C 0x3C 0x38 0x18 0x18 0x18 0x18 0x10 0x00 0x1C 0x3C 0x1C 0x7C 0x7C 0x7C 0x3C 0x3C 0x38 0x18 0x18 0x18 0x18 0x10 0x00 0x1C 0x3C","options":{"tickrate":100,"fillColor":"#FF00FF","fillColor2":"#00FFFF","blendColor":"#FFFFFF","backgroundColor":"#000000","buzzColor":"#990099","quietColor":"#222","shiftQuirks":false,"loadStoreQuirks":false,"vfOrderQuirks":false,"clipQuirks":false,"vBlankQuirks":false,"jumpQuirks":false,"screenRotation":0,"maxSize":3584,"touchInputMode":"none","logicQuirks":false,"fontStyle":"octo","displayScale":"4"},"rom":[34,22,72,1,34,42,72,2,34,112,72,3,34,148,72,4,34,174,18,2,0,238,104,1,0,238,104,2,0,238,104,3,0,238,104,4,0,238,0,0,0,0,0,224,0,254,97,11,98,5,242,1,166,179,209,47,113,8,166,194,209,39,113,6,166,201,209,41,113,6,166,201,209,41,166,210,97,20,98,16,209,45,113,8,166,223,209,39,113,7,166,194,209,39,113,6,166,230,209,40,113,7,166,238,209,42,240,10,34,112,0,238,0,255,106,52,107,24,122,254,108,1,109,0,101,0,102,0,103,0,37,196,37,208,37,242,36,76,34,228,35,200,72,1,18,136,0,238,37,234,97,0,98,25,129,36,63,1,18,166,37,234,122,255,37,234,58,0,18,152,34,34,0,238,243,1,0,224,37,242,243,1,166,248,97,28,98,24,209,32,167,56,97,44,98,22,209,32,167,120,97,60,98,26,209,32,167,184,97,74,98,23,209,32,167,248,97,90,98,25,209,47,240,10,34,22,0,238,96,5,224,161,19,104,96,7,224,161,19,8,96,8,224,161,19,152,96,9,224,161,19,56,0,238,37,208,138,16,139,32,37,208,0,238,130,176,129,160,113,255,65,255,97,0,145,160,0,238,111,52,143,23,79,0,18,254,111,72,143,21,79,0,18,254,111,16,143,37,63,0,18,254,111,40,143,39,63,0,18,254,0,238,130,176,129,160,113,1,65,124,97,123,145,160,0,238,111,52,143,23,79,0,18,254,111,72,143,21,79,0,18,254,111,16,143,37,63,0,18,254,111,40,143,39,63,0,18,254,0,238,129,160,130,176,114,255,66,255,98,0,146,176,0,238,111,52,143,23,79,0,18,254,111,72,143,21,79,0,18,254,111,16,143,37,63,0,18,254,111,40,143,39,63,0,18,254,0,238,129,160,130,176,114,1,66,55,98,54,146,176,0,238,111,52,143,23,79,0,18,254,111,72,143,21,79,0,18,254,111,16,143,37,63,0,18,254,111,40,143,39,63,0,18,254,0,238,35,254,100,10,67,0,19,222,135,52,63,1,19,220,37,242,117,1,35,242,19,240,135,69,63,0,19,240,37,242,100,1,133,69,79,0,101,0,35,242,0,238,53,100,19,250,101,10,118,1,37,242,0,238,76,0,20,16,76,1,20,18,76,2,20,70,76,3,20,72,0,238,0,238,100,0,111,24,143,183,63,0,20,34,99,24,132,176,132,55,111,30,143,181,63,0,20,48,99,30,132,176,132,53,111,52,143,165,63,0,20,64,131,160,115,204,132,52,132,52,36,74,131,64,0,238,0,238,0,238,0,238,162,38,81,67,142,16,96,1,142,2,78,0,20,94,36,160,0,238,77,0,20,102,125,255,0,238,97,1,194,1,99,249,129,50,131,32,131,62,129,49,98,120,195,10,115,251,131,180,100,0,37,168,36,132,0,238,142,16,96,6,142,2,142,230,96,32,166,75,78,0,20,154,240,30,126,255,20,144,243,1,210,63,0,238,66,0,21,174,96,200,132,4,79,1,20,212,37,168,0,238,111,52,143,39,79,0,20,212,111,72,143,37,79,0,20,212,111,16,143,53,63,0,20,212,111,40,143,55,63,0,20,212,37,174,0,238,128,160,112,5,143,0,143,37,79,0,21,8,128,32,112,7,143,160,143,7,79,0,21,8,128,48,112,5,143,176,143,7,79,0,21,8,128,176,112,10,143,0,143,53,79,0,21,8,37,188,0,238,36,132,128,16,110,6,128,226,128,6,128,14,181,24,0,238,21,30,21,36,0,238,114,255,37,162,0,238,114,255,128,16,110,8,128,226,128,6,128,6,128,6,206,150,78,0,37,66,64,0,21,132,64,1,21,102,0,238,48,0,21,86,110,247,129,226,110,1,142,238,142,238,142,238,129,225,21,100,110,247,129,226,110,0,142,238,142,238,142,238,129,225,0,238,115,255,111,64,143,53,63,0,21,128,99,0,96,247,129,2,96,0,128,14,128,14,128,14,129,1,37,162,0,238,115,1,111,58,143,53,63,0,21,158,99,58,96,247,129,2,96,1,128,14,128,14,128,14,129,1,37,162,0,238,36,132,37,168,0,238,162,38,81,66,0,238,96,254,129,2,205,30,125,10,36,132,37,168,0,238,37,174,37,208,34,30,0,238,97,56,98,24,166,43,242,1,209,32,0,238,166,139,242,1,218,186,60,1,21,232,128,160,35,254,128,53,79,0,96,0,241,1,208,186,0,238,166,159,242,1,218,186,0,238,241,1,97,1,98,53,166,169,209,42,38,0,0,238,166,40,245,51,242,101,100,12,105,58,241,41,212,149,242,41,116,5,212,149,96,0,97,0,144,96,22,38,116,5,241,41,212,149,112,1,22,24,0,238,0,0,0,0,0,0,0,1,248,7,252,15,250,17,247,32,239,64,95,128,63,128,63,128,63,128,62,128,60,128,56,128,48,255,224,3,7,30,120,224,192,0,0,0,0,0,0,0,0,0,3,7,30,120,224,192,0,0,0,0,0,0,0,0,0,0,0,56,92,182,182,92,56,0,0,0,0,0,0,0,0,0,56,92,182,182,92,56,0,0,0,0,0,0,0,0,0,0,0,32,80,80,160,240,40,32,80,80,80,32,80,80,40,120,160,32,80,80,80,32,80,80,164,120,22,8,6,0,0,126,129,165,129,66,60,126,255,255,255,192,254,127,15,6,6,2,2,2,2,6,198,206,252,120,120,216,136,240,132,252,120,60,126,98,96,240,120,108,96,224,28,50,97,193,129,129,129,131,151,142,92,50,1,206,132,132,132,204,124,56,60,102,98,48,24,140,204,120,24,56,48,240,120,60,48,176,240,96,0,0,7,224,30,56,60,12,56,0,120,0,112,0,240,0,224,124,225,252,225,206,241,142,112,7,60,7,31,14,7,252,0,0,7,224,30,56,60,12,56,0,120,0,112,0,240,0,224,124,225,252,225,206,241,142,112,7,60,7,31,14,7,252,0,0,7,224,30,120,60,28,56,14,120,6,112,6,240,3,224,3,224,3,224,3,240,3,112,7,60,7,31,14,7,252,0,0,7,224,30,120,60,28,56,14,120,6,112,6,240,3,224,3,224,3,224,3,240,3,112,7,60,7,31,14,7,252,7,128,12,240,24,28,16,4,16,4,16,4,16,0,25,240,15,252,3,254,32,14,96,14,120,14,127,30,63,252,63,240,7,128,12,240,24,28,16,4,16,4,16,4,16,0,25,240,15,252,3,254,32,14,96,14,120,14,127,30,63,252,63,240,120,30,112,12,48,12,56,12,24,12,24,24,25,248,15,248,15,204,15,12,12,12,12,14,8,6,24,7,28,7,60,6,120,30,112,12,48,12,56,12,24,12,24,24,25,248,15,248,15,204,15,12,12,12,12,14,8,6,24,7,28,7,60,6,28,124,124,124,60,60,56,24,24,24,24,16,0,28,60,28,124,124,124,60,60,56,24,24,24,24,16,0,28,60]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var smallfonts = {
	octo: [
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	],
	vip: [
		0xF0, 0x90, 0x90, 0x90, 0xF0,
		0x60, 0x20, 0x20, 0x20, 0x70,
		0xF0, 0x10, 0xF0, 0x80, 0xF0,
		0xF0, 0x10, 0xF0, 0x10, 0xF0,
		0xA0, 0xA0, 0xF0, 0x20, 0x20,
		0xF0, 0x80, 0xF0, 0x10, 0xF0,
		0xF0, 0x80, 0xF0, 0x90, 0xF0,
		0xF0, 0x10, 0x10, 0x10, 0x10,
		0xF0, 0x90, 0xF0, 0x90, 0xF0,
		0xF0, 0x90, 0xF0, 0x10, 0xF0,
		0xF0, 0x90, 0xF0, 0x90, 0x90,
		0xF0, 0x50, 0x70, 0x50, 0xF0,
		0xF0, 0x80, 0x80, 0x80, 0xF0,
		0xF0, 0x50, 0x50, 0x50, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0x80,
	],
	dream6800: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x40, 0x40, 0x40, 0x40, 0x40,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0x80, 0xA0, 0xA0, 0xE0, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xE0, 0xA0, 0xC0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	eti660: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x20, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0xA0, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0x80, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0x20, 0x20, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	fish: [
		0x60, 0xA0, 0xA0, 0xA0, 0xC0,
		0x40, 0xC0, 0x40, 0x40, 0xE0,
		0xC0, 0x20, 0x40, 0x80, 0xE0,
		0xC0, 0x20, 0x40, 0x20, 0xC0,
		0x20, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xC0, 0x20, 0xC0,
		0x40, 0x80, 0xC0, 0xA0, 0x40,
		0xE0, 0x20, 0x60, 0x40, 0x40,
		0x40, 0xA0, 0x40, 0xA0, 0x40,
		0x40, 0xA0, 0x60, 0x20, 0x40,
		0x40, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xC0, 0xA0, 0xC0,
		0x60, 0x80, 0x80, 0x80, 0x60,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xC0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
}
var bigfonts = {
	octo: [
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	],
	schip: [
		0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C,
		0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
		0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
		0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
		0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
		0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
		0x3E, 0x7C, 0xE0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
		0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no hex chars!
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	],
	fish: [
		0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // at most 7x9 pixels!
		0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
		0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00,
		0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00,
		0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
		0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00,
		0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00,
		0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
		0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
		0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00,
		0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
		0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00,
		0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00,
	],
	none: new Array(16*10).fill(0x00),
}
var fontsets = {
	octo     : { small: smallfonts.octo,      big: bigfonts.octo  },
	vip      : { small: smallfonts.vip,       big: bigfonts.none  },
	dream6800: { small: smallfonts.dream6800, big: bigfonts.none  },
	eti660   : { small: smallfonts.eti660,    big: bigfonts.none  },
	schip    : { small: smallfonts.octo,      big: bigfonts.schip },
	fish     : { small: smallfonts.fish,      big: bigfonts.fish  },
}

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.logicQuirks        = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;//must be 0, 90, 180, or 270
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";
	this.fontStyle          = 'octo';

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.pattern = [];  // audio pattern buffer
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;
	this.linted = false;

	// external interface stubs
	this.exitVector  = function() {}                                   // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                              // save persistent flags
	this.buzzTrigger = function(ticks, remainingTicks) {}                              // fired when buzzer played

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		var font = fontsets[this.fontStyle];
		for(var z = 0; z < 32*64;            z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.small.length;z++) { this.m[z] = font.small[z]; }
		for(var z = 0; z < font.big.length;  z++) { this.m[z + font.small.length] = font.big[z]; }
		for(var z = 0; z < rom.rom.length;   z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;               z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;               z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x2: this.v[x] &= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x3: this.v[x] ^= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op);
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01:
				this.plane = (x & 0x3);
				break;
			case 0x02:
				for(var z = 0; z < 16; z++) {
					this.pattern[z] = this.m[this.i+z];
				}
				break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTrigger(this.v[x], this.st); this.st = this.v[x]; break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + fontsets[this.fontStyle].small.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest);
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op);
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op);
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o);
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

//must be set > 0
var scaleFactor = 5;
//dom id for canvas element
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
	"logicQuirks",
	"fontStyle",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function setTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			console.assert(emulator.screenRotation === 0, 'Screen rotation not set to 0, 90, 180, or 270. Treating as 0.')
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	setTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var TIMER_FREQ = 60;
var SAMPLES = 16;
var BUFFER_SIZE = SAMPLES * 8


function audioEnable() {
	// this will only work if called directly from a user-generated input handler:
	if (audio && audio.state == 'suspended') audio.resume()
}

function audioSetup() {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	audioEnable()
	if (audio && !audioNode) {
		audioNode = audio.createScriptProcessor(4096, 1, 1);
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;

			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audio.destination);
		return true;
	}
	if (audio && audioNode) { return true; }
	return false;
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

var VOLUME = 0.25;

function playPattern(soundLength, buffer, remainingTicks) {
	if (!audio) { return; }
	audioEnable()

	var samples = Math.floor(BUFFER_SIZE * audio.sampleRate / FREQ);
	var audioBuffer = new Array(samples);
	if (remainingTicks && audioData.length > 0) {
		audioData[audioData.length - 1].dequeue(Math.floor(remainingTicks * audio.sampleRate / TIMER_FREQ));
	}

	for(var i = 0; i < samples; ++i) {
		var srcIndex = Math.floor(i * FREQ / audio.sampleRate);
		var cell = srcIndex >> 3;
		var bit = srcIndex & 7;
		audioBuffer[i] = (buffer[srcIndex >> 3] & (0x80 >> bit)) ? VOLUME: 0;
	}
	audioData.push(new AudioBuffer(audioBuffer, Math.floor(soundLength * audio.sampleRate / TIMER_FREQ)));
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move )
      ael(screen, 'touchend',   end  )
      screen.uninstallSeg16 = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move )
        rel(screen, 'touchend',   end  )
      }
    },
    remove:  (screen) => {
      screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i]) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => {
        ael(b, 'touchstart', start)
        ael(b, 'touchend',   end  )
      })
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  // defer installing adaptive input until we actually see
  // an input event from the user:
  ael(screen, 'touchstart', install)
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(data.options.displayScale || 4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup()
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
intervalHandle = setInterval(_=>{
	if (emulator.halted) return
	for(var z = 0; (z<emulator.tickrate) && (!emulator.waiting); z++) emulator.tick()
	if (emulator.dt > 0) emulator.dt--
	if (emulator.st > 0) emulator.st--
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, 1000/60)

injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
