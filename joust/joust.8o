# Structure for individual notes
:alias type			v9	# type of note
:alias input		va	# key code note looks for
:alias px			vb	# x position of the note
:alias py 			vc	# y position of the note (lane, not actual position)
:alias charge 		vd	# charge granted by the note
#:alias ???			vc 
#:alias ???			vd 
#:alias ???			ve 

# World state
:alias state 		v4
:alias pc-charge	v5
:alias npc-charge	v6
:alias spawn-timer	v7
:alias next-spawn	v8

:alias j v0
:alias x v1
:alias y v2

:const PC_PLANE		2
:const NPC_PLANE	1

:const DRAW_HIT_SPOT_MIN	105
:const DRAW_HIT_SPOT_MAX 	110
:const HIT_SPOT_MIN 		98
:const HIT_SPOT_MAX 		110

: main
	hires

	next-spawn := 30

	draw-ground
	setup-player

	npc-charge := 0
	pc-charge := 0

	loop
		loop-notes
		read-input
		note-factory
	again
;

: setup-player
	draw-player
;

# check whether to spawn a new note
: note-factory
	spawn-timer += 1
	if spawn-timer == next-spawn then generate-new-note
;

# generate details of a new note
: generate-new-note
	type := random 1
	type += 1

	#:breakpoint generate-new-note 
	input := random 3
	input += 0x7

	px := 0
	py := random 1

	charge := 10

	spawn-note

	spawn-timer := 0
	next-spawn := random 8
	next-spawn += 10
;

: read-input
	v0 := 0x7
	if v0 key then jump process-input
	
	v0 := 0x8
	if v0 key then jump process-input

	v0 := 0x9
	if v0 key then jump process-input

	v0 := 0xA
	if v0 key then jump process-input
;

# if input made, go through notes to see if there is one in sweet spot,
# and determine if input is correct for it
: process-input
	i := notes
	v2 := 0
	v3 := 8

	loop
		load-note

		if type != 0 begin
			can-hit-note

			if v1 == 1 then jump hit-note
		end

		i += v3
		v2 += 1
		while v2 != 10
	again
;

# process result of hitting the current note
# v0 is the key that was hit
: hit-note
	if type == NPC_PLANE 	then jump process-bad-hit
	if input != v0 			then jump process-bad-hit

	process-good-hit
;

# process hitting the note correctly
: process-good-hit
	v3 := v2
	add-pc-charge
	remove-note
;

# process hitting the note poorly
: process-bad-hit
	v3 := v2
	add-npc-charge
	remove-note
;

: remove-note
	draw-note

	type := 0

	v3 <<= v3
	v3 <<= v3
	v3 <<= v3

	i := notes
	i += v3
	save type - charge
;

# determines if the current note is in the hit zone, and saves result to v1
: can-hit-note
	v1 := 1
	if px < HIT_SPOT_MIN then v1 := 0
	if px > HIT_SPOT_MAX then v1 := 0
;

# loop through notes and call update on each
: loop-notes
	v0 := 0

	loop
		update-note
		v0 += 1
		while v0 != 10
	again
;

# draw and update an individual note
# this loads the note in memory, based on index counter v0 set by :loop-notes
: update-note
	v1 := v0
	note-index-to-offset

	i := notes
	i += v1

	load-note

	if type == 0 then return

	draw-note
	step-note
	draw-note
;

: note-index-to-offset
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
;

# loads the note at the current i position
: load-note
	load type - charge
;

# v1 is the memory offset of the current note
: save-note
	i := notes
	i += v1
	save type - charge
;

# step the note loaded into memory
: step-note

	# kill when off-screen
	if px >= 125 then type := 0

	px += 3
	save-note
;

# draws the note loaded into memory
: draw-note
	if type == 0 then return

	get-note-sprite

	# lane
	if py == 0 then v2 := 2
	if py == 1 then v2 := 12
	if py == 2 then v2 := 22

	sprite px v2 8
;

# sets i to the sprite associated with the current note
: get-note-sprite
	# opponent
	if type == 1 begin
		plane 1
		if input == 0x0 then i := note-simple-q
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
		if input == 0xA then i := note-simple-f
	end

	# player
	if type == 2 begin
		plane 2
		if input == 0x0 then i := note-simple-q
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
		if input == 0xA then i := note-simple-f
	end
;

# saves a new note to the first empty note slot
# the data of the note should already be populated to the registers
: spawn-note
	draw-note

	# find empty memory
	i := notes

	loop
		load v1 - v1

		v0 := 8
		if v1 != 0 then i += v0
		while v1 != 0
	again

	save type - charge
;

# add the charge of the current note to the pc charge
: add-pc-charge
	draw-pc-charge
	pc-charge += charge
;

# add the charge of the current note to the npc charge
: add-npc-charge
	draw-npc-charge
	npc-charge += charge
;

## DRAW ROUTINES #############################################################

: draw-ground
	vc := 0
	vd := 49
	i := ground

	loop
		plane 1
		sprite vc vd 13
		plane 2
		sprite vc vd 13
		
		vc += 8
		while vc != 128
	again

	i := fill-bar

	vc := DRAW_HIT_SPOT_MIN
	vd := 0
	plane 1
	sprite vc vd 2

	vc := DRAW_HIT_SPOT_MAX
	plane 2
	sprite vc vd 2

;

: draw-player
	x := 100
	y := 33

	plane 1
	i := hors
	sprite x y 0

	i := mans
	x += 7
	plane 2
	sprite x y 12

	plane 1
	i := hats
	sprite x y 1

	i := lance
	x := -37
	y += 5
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0	
;

: draw-npc-charge
	x := npc-charge
	y := 62
	j := x
	j += charge

	plane NPC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != j
	again
;

: draw-pc-charge
	:breakpoint draw-pc-charge
	x := pc-charge
	y := 255
	x =- y
	x += 1
	j := x
	x -= charge
	y := 62


	plane PC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != j
	again
;

## SPRITES ###################################################################
: mans
0x60 0xC0 0xC0 0x40 0x60 0xE0 0xE0 0x60 
0x40 0x40 0x40 0x40

: hats
0x60

: lance
0x00 0x07 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: hors
0x00 0x00 0x60 0x00 0xF0 0x00 0xF0 0x00 
0xF8 0x00 0xD8 0x00 0x1C 0x00 0x1F 0x1C 
0x3F 0x7C 0x3F 0x7C 0x3F 0x7C 0x27 0x1C 
0x24 0x1C 0x24 0x14 0x24 0x14 0x24 0x14    

: ground
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 
0xFF 0xFF 0xFF 0xFF 0xFF

: gate
0xFF 0xFF 0x11 0x11 0x11 0x11 0x11 0xFF

: fill-bar 0x80 0x80

: note-simple-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-simple-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-simple-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-simple-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-simple-q 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

## MEMORY ####################################################################

# allocate in blocks of eight for easy multiplication
: notes
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0