# Structure for individual notes
:alias type			v7	# type of note
:alias input		v8	# key code note looks for
:alias px			v9	# x position of the note
:alias py 			va	# y position of the note (lane, not actual position)
:alias charge 		vb	# charge granted by the note
#:alias ???			vc 
#:alias ???			vd 
#:alias ???			ve 

# World state
:alias state 		v4
:alias pc-charge	v5
:alias npc-charge	v6

:alias j v0
:alias x v1
:alias y v2

:const PC_PLANE		2
:const NPC_PLANE	1 
:const KILL_NOTE	127

:const DRAW_HIT_SPOT_MIN	105
:const DRAW_HIT_SPOT_MAX 	110
:const HIT_SPOT_MIN 		98
:const HIT_SPOT_MAX 		110

: main
	hires

	draw-ground
	setup-player

	npc-charge := 1
	pc-charge := 2
	draw-npc-charge
	draw-pc-charge

	# example notes
	type := 1
	input := 0x7
	px := 40
	py := 0
	charge := 10
	spawn-note

	type := 2
	input := 0x8
	px := 10
	py := 1
	charge := 10
	spawn-note

	loop
		loop-notes
		read-input
	again
;

: setup-player
	draw-player
;

: read-input
	v0 := 0x7
	if v0 key then jump process-input
	
	v0 := 0x8
	if v0 key then jump process-input

	v0 := 0x9
	if v0 key then jump process-input
;

# if input made, go through notes to see if there is one in sweet spot,
# and determine if input is correct for it
: process-input
	i := notes
	v2 := 0
	v3 := 8

	loop
		load-note

		if type != 0 begin
			can-hit-note

			if v1 == 1 then jump hit-note
		end

		i += v3
		v2 += 1
		while v2 != 10
	again
;

# process result of hitting the current note
# v0 is the key that was hit
: hit-note
	if type == NPC_PLANE 	then jump process-bad-hit
	if input != v0 			then jump process-bad-hit

	process-good-hit
;

# process hitting the note correctly
: process-good-hit
	v3 := v2
	add-pc-charge
	remove-note
;

# process hitting the note poorly
: process-bad-hit
	v3 := v2
	add-npc-charge
	remove-note
;

: remove-note
	draw-note

	type := 0

	v3 <<= v3
	v3 <<= v3
	v3 <<= v3

	i := notes
	i += v3
	save type - charge
;

# determines if the current note is in the hit zone, and saves result to v1
: can-hit-note
	v1 := 1
	if px < HIT_SPOT_MIN then v1 := 0
	if px > HIT_SPOT_MAX then v1 := 0
;

# loop through notes and call update on each
: loop-notes
	v0 := 0

	loop
		update-note
		v0 += 1
		while v0 != 10
	again
;

# draw and update an individual note
# this loads the note in memory, based on index counter v0 set by :loop-notes
: update-note
	v1 := v0
	note-index-to-offset

	i := notes
	i += v1

	load-note

	if type == 0 then return

	draw-note
	step-note
	draw-note
;

: note-index-to-offset
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
;

# loads the note at the current i position
: load-note
	load type - charge
;

# v1 is the memory offset of the current note
: save-note
	i := notes
	i += v1
	save type - charge
;

# step the note loaded into memory
: step-note

	# kill when off-screen
	if px >= 125 then type := 0

	px += 3
	save-note
;

# draws the note loaded into memory
: draw-note
	if type == 0 then return

	note-factory

	# lane
	if py == 0 then v2 := 2
	if py == 1 then v2 := 12
	if py == 2 then v2 := 22

	sprite px v2 8
;

# sets i to the sprite associated with the current note
: note-factory
	if type == 1 begin
		plane 1
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
	end

	if type == 2 begin
		plane 2
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
	end
;

# saves a new note to the first empty note slot
# the data of the note should already be populated to the registers
: spawn-note
	draw-note

	# find empty memory
	i := notes

	loop
		load v1 - v1

		v0 := 8
		if v1 != 0 then i += v0
		while v1 != 0
	again

	save type - charge
;

# add the charge of the current note to the pc charge
: add-pc-charge
	draw-pc-charge
	pc-charge += charge
	draw-pc-charge
;

# add the charge of the current note to the npc charge
: add-npc-charge
	draw-npc-charge
	npc-charge += charge
	draw-npc-charge
;

## DRAW ROUTINES #############################################################

: draw-ground
	vc := 0
	vd := 49
	i := ground

	loop
		plane 1
		sprite vc vd 13
		plane 2
		sprite vc vd 13
		
		vc += 8
		while vc != 128
	again

	i := fill-bar

	vc := DRAW_HIT_SPOT_MIN
	vd := 0
	plane 1
	sprite vc vd 2

	vc := DRAW_HIT_SPOT_MAX
	plane 2
	sprite vc vd 2

;

: draw-player
	x := 100
	y := 33

	plane 1
	i := hors
	sprite x y 0

	i := mans
	x += 7
	plane 2
	sprite x y 12

	plane 1
	i := hats
	sprite x y 1

	i := lance
	x := -37
	y += 5
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0	
;

: draw-npc-charge
	x := 0
	y := 62
	j := 0

	plane NPC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != npc-charge
	again
;

: draw-pc-charge
	x := 127
	y := 62
	j := 0

	plane PC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += -1
		j += 1
		while j != pc-charge
	again
;

## SPRITES ###################################################################
: mans
0x60 0xC0 0xC0 0x40 0x60 0xE0 0xE0 0x60 
0x40 0x40 0x40 0x40

: hats
0x60

: lance
0x00 0x07 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: hors
0x00 0x00 0x60 0x00 0xF0 0x00 0xF0 0x00 
0xF8 0x00 0xD8 0x00 0x1C 0x00 0x1F 0x1C 
0x3F 0x7C 0x3F 0x7C 0x3F 0x7C 0x27 0x1C 
0x24 0x1C 0x24 0x14 0x24 0x14 0x24 0x14    

: ground
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 
0xFF 0xFF 0xFF 0xFF 0xFF

: gate
0xFF 0xFF 0x11 0x11 0x11 0x11 0x11 0xFF

: fill-bar 0x80 0x80

: note-simple-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-simple-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-simple-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E

## MEMORY ####################################################################

# allocate in blocks of eight for easy multiplication
: notes
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0