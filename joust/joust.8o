# Structure for individual notes
:alias type			v1	# type of note
:alias input		v1	# key code note looks for
:alias details		va	# type of node (0xF0) and key code (0x0F)
:alias px			vb	# x position of the note
:alias py 			vc	# y position of the note (lane, not actual position)
#:alias ???			vc 
#:alias ???			vd 
#:alias ???			ve 

:const MASK_TYPE	0b11110000
:const MASK_INPUT	0b00001111

# Structure for charging
:alias pxl			v9	# position of the left horse
:alias pxr			va	# position of the right horse
:alias ticker		vb

# Constant world state
:alias gamestate	v0
:alias opponent 	v1
:alias state 		v4	# opponent step (0xF0) and game state (0x0F)
:alias pc-charge	v5
:alias npc-charge	v6

:const MASK_OPPONENT 0b11110000
:const MASK_STATE	 0b00001111

# taptap world state
:alias spawn-timer	v7
:alias next-spawn	v8
:alias charge 		vd	# charge granted by the note

# note generation state
# (we can override note structure at this point)
:alias direction 	v9

# charge world state
:alias fall-ticks	v7	# ticks since the collision
:alias fall-step	v8	# step of the fall

:alias j v0
:alias x v1
:alias y v2

:const STATE_TITLE		0
:const STATE_OPPONENT	1
:const STATE_TAPTAP		2
:const STATE_CHARGE		3
:const STATE_NPC_LOSE	4
:const STATE_PC_LOSE 	5
:const STATE_RESULT	 	6

:const NOTE_NONE		0	# not an active note
:const NOTE_STD_1		1	# standard block note for layer 1
:const NOTE_STD_2		2	# standard block note for layer 2
:const NOTE_STD_Q_1		3	# note hides input until last moment
:const NOTE_STD_Q_2		4
:const NOTE_SPLIT_1		5	# a note that splits lanes before it switches to one
:const NOTE_SPLIT_2		6
:const NOTE_SPLIT_Q_1	7	# split lanes and hide input
:const NOTE_SPLIT_Q_2	8

:const PC_PLANE		2
:const NPC_PLANE	1

:const DRAW_HIT_SPOT_MIN	62
:const DRAW_HIT_SPOT_MAX 	67
:const HIT_SPOT_MIN 		55
:const HIT_SPOT_MAX 		67
:const DECISION_X			40
:const DECISION_X_RIGHT		84

:const PLAYER_X				96
:const CHARACTER_Y			33
:const JOUST_X				48	# x position of npc at the collision point

:const DEFAULT_CHARGE		4

: main
	opponent := 10
	setopponent
	gamestate := STATE_OPPONENT
	setstate

	loop
		getstate
		if gamestate == STATE_TITLE		then title-screen
		if gamestate == STATE_OPPONENT	then opponent-screen
		if gamestate == STATE_TAPTAP	then game-loop
		if gamestate == STATE_CHARGE	then charge-state
		if gamestate == STATE_NPC_LOSE	then charge-state
		if gamestate == STATE_PC_LOSE	then charge-state
		if gamestate == STATE_RESULT	then result-state
	again
;

## MEMORY ####################################################################

: bcd-num 0 0 0

: level-scores 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

# allocate in blocks of eight for easy multiplication
: notes
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0

## DATAFYING #################################################################
: gettype
	v1 := details
	v1 >>= v1
	v1 >>= v1
	v1 >>= v1
	v1 >>= v1
;

: settype
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1

	vf := MASK_INPUT
	details &= vf
	details += v1
;

: getinput
	v1 := MASK_INPUT
	v1 &= details
;

: setinput
	vf := MASK_TYPE
	details &= vf
	details += v1
;

: getopponent
	opponent := state
	opponent >>= opponent
	opponent >>= opponent
	opponent >>= opponent
	opponent >>= opponent
;

: setopponent
	opponent <<= opponent
	opponent <<= opponent
	opponent <<= opponent
	opponent <<= opponent

	vf := MASK_STATE
	state &= vf
	state += opponent
;

: getstate
	gamestate := MASK_STATE
	gamestate &= state
;

: setstate
	vf := MASK_OPPONENT
	state &= vf
	state += gamestate
;

## JUMP SPACE ################################################################
: gothicnum
	#v0 := v1
	#v0 <<= v0
	#v0 <<= v0
	#jump0 goto-gothic-num

	v0 := 0
	ve := 30
	i := num0

	loop
		while v0 != v1
		i += ve
		v0 += 1
	again
;

: num0
0x1D 0x22 0x42 0x46 0x4A 0x52 0x62 0x42 
0x44 0xB8 0x00 0x00 0x00 0x00 0x00 0x1D 
0x22 0x42 0x46 0x4A 0x52 0x62 0x42 0x44 
0xB8 0x00 0x00 0x00 0x00 0x00

#: num1
0x1C 0x34 0x74 0x14 0x14 0x14 0x14 0x14 
0x1C 0x3E 0x00 0x00 0x00 0x00 0x00 0x1C 
0x34 0x74 0x14 0x14 0x14 0x14 0x14 0x1C 
0x3E 0x00 0x00 0x00 0x00 0x00

#: num2
0x3A 0x4C 0x04 0x0C 0x18 0x30 0x60 0xD8 
0xE4 0x42 0x00 0x00 0x00 0x00 0x00 0x3A 
0x4C 0x04 0x0C 0x18 0x30 0x60 0xD8 0xE4 
0x42 0x00 0x00 0x00 0x00 0x00 

#: num3
0x38 0x46 0x02 0x12 0x0C 0x12 0x02 0x46 
0x3E 0x1C 0x00 0x00 0x00 0x00 0x00 0x38 
0x46 0x02 0x12 0x0C 0x12 0x02 0x46 0x3E 
0x1C 0x00 0x00 0x00 0x00 0x00 

#: num4
0x0A 0x14 0x24 0x44 0x84 0x45 0x7E 0x85 
0x0C 0x1E 0x00 0x00 0x00 0x00 0x00 0x0A 
0x14 0x24 0x44 0x84 0x45 0x7E 0x85 0x0C 
0x1E 0x00 0x00 0x00 0x00 0x00 

#: num5
0xBC 0x62 0x60 0x60 0x78 0x0C 0x06 0x42 
0x6C 0x92 0x00 0x00 0x00 0x00 0x00 0xBC 
0x62 0x60 0x60 0x78 0x0C 0x06 0x42 0x6C 
0x92 0x00 0x00 0x00 0x00 0x00 

#: num6
0xBC 0x66 0x40 0x40 0x49 0x56 0x62 0x42 
0x62 0xBC 0x42 0x00 0x00 0x00 0x00 0xBC 
0x66 0x40 0x40 0x49 0x56 0x62 0x42 0x62 
0xBC 0x42 0x00 0x00 0x00 0x00 

#: num7
0x3E 0x7F 0x41 0x23 0x06 0x0C 0x18 0x30 
0x34 0x38 0x00 0x00 0x00 0x00 0x00 0x3E 
0x7F 0x41 0x23 0x06 0x0C 0x18 0x30 0x34 
0x38 0x00 0x00 0x00 0x00 0x00 

#: num8
0x3C 0x46 0x46 0x2C 0x18 0x2C 0x46 0x46 
0x4E 0x3C 0x00 0x00 0x00 0x00 0x00 0x3C 
0x46 0x46 0x2C 0x18 0x2C 0x46 0x46 0x4E 
0x3C 0x00 0x00 0x00 0x00 0x00 

#: num9
0x1C 0x22 0x42 0x42 0x62 0x36 0x1A 0x02 
0x24 0x3A 0x00 0x00 0x00 0x00 0x00 0x1C 
0x22 0x42 0x42 0x62 0x36 0x1A 0x02 0x24 
0x3A 0x00 0x00 0x00 0x00 0x00 

## GAME LOOP #################################################################
: game-loop
	clear

	hires
	draw-ground
	setup-player

	next-spawn := 30

	loop
		getstate
		if gamestate != STATE_TAPTAP then jump exit-taptap

		vf := 2
		delay := vf

		loop
			vf := delay
			if vf != 0 then
		again

		loop-notes
		read-input
		note-factory
	again
;

: setup-player
	draw-player
;

# look for keyboard input
: read-input
	v3 := 0x7
	if v3 key then jump process-input
	
	v3 := 0x8
	if v3 key then jump process-input

	v3 := 0x9
	if v3 key then jump process-input

	v3 := 0xE
	if v3 key then jump process-input

	v3 := 0x4
	if v3 key then jump process-input
	
	v3 := 0x5
	if v3 key then jump process-input

	v3 := 0x6
	if v3 key then jump process-input

	v3 := 0xD
	if v3 key then jump process-input
;

# if input made, go through notes to see if there is one in sweet spot,
# and determine if input is correct for it
: process-input
	v0 := 0

	loop
		load-note
		gettype

		if type != NOTE_NONE begin
			can-hit-note

			if v1 == 1 then jump hit-note
		end

		v0 += 1
		while v0 != 10
	again
;

# process result of hitting the current note
# v0 is the key that was hit
: hit-note
	gettype
	v1 += -1

	if v1 != py 		then jump process-bad-hit

	getinput
	if input != v3 		then jump process-bad-hit

	process-good-hit
;

# process hitting the note correctly
: process-good-hit
	load-note
	charge := DEFAULT_CHARGE
	add-pc-charge
	remove-note
;

# process hitting the note poorly
: process-bad-hit
	load-note
	charge := DEFAULT_CHARGE
	add-npc-charge
	
	if v1 == 0 then remove-note

	v0 := 10
	buzzer := v0
;

: remove-note
	gettype
	if type == NOTE_NONE then return

	draw-note

	type := 0
	settype
	save-note
;

# determines if the current note is in the hit zone, and saves result to v1
: can-hit-note
	v1 := 1
	if px < HIT_SPOT_MIN then v1 := 0
	if px > HIT_SPOT_MAX then v1 := 0
;

# loop through notes and call update on each
: loop-notes
	v0 := 0

	loop
		update-note
		v0 += 1
		while v0 != 10
	again
;

# draw and update an individual note
# this loads the note in memory, based on index counter v0 set by :loop-notes
: update-note
	load-note-type
	gettype

	if type == NOTE_NONE then return
	
	load-note
	gettype

	draw-note
	step-note
	draw-note
;

# convert v0 into memory offset and put in v1
: note-index-to-offset
	v1 := v0
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
;

# loads a note from memory
# v0 is index of the note to load
# uses v1 to store memory offset
: load-note
	note-index-to-offset
	i := notes
	i += v1
	load details - charge
;

# only load the details for the note
: load-note-type
	note-index-to-offset
	i := notes
	i += v1
	load details - details
;

# v0 is the index of the current note
# uses v1 to store memory offset
: save-note
	note-index-to-offset
	i := notes
	i += v1
	save details - charge
;

# step the note loaded into memory
: step-note
	gettype

	do-behavior

	step-note-position
	save-note
;

: step-note-position
	getinput
	if input == 0x0 then px += 2
	if input == 0x7 then px += 2
	if input == 0x8 then px += 2
	if input == 0x9 then px += 2
	if input == 0xE then px += 2
	if input == 0xB then px += -2
	if input == 0x4 then px += -2
	if input == 0x5 then px += -2
	if input == 0x6 then px += -2
	if input == 0xD then px += -2
;

# draws the note loaded into memory
: draw-note
	gettype
	if type == NOTE_NONE then return

	# lane
	if py == 0 then v2 := 2
	if py == 1 then v2 := 12
	if py == 2 then v2 := 7

	get-note-sprite
;

# saves a new note to the first empty note slot
# the data of the note should already be populated to the registers
: spawn-note
	draw-note

	# find empty memory
	i := notes

	loop
		load v1 - v1
		v1 >>= v1
		v1 >>= v1
		v1 >>= v1
		v1 >>= v1

		v0 := 8
		if v1 != NOTE_NONE then i += v0
		while v1 != NOTE_NONE
	again

	save details - charge
;

# add the charge of the current note to the pc charge
: add-pc-charge
	draw-pc-charge-meter
	pc-charge += charge

	check-charges
;

# add the charge of the current note to the npc charge
: add-npc-charge
	draw-npc-charge-meter
	npc-charge += charge

	check-charges
;

# look for when the charges meet
: check-charges
	v1 := pc-charge
	v1 += npc-charge

	if v1 >= 128 begin 
		goto-charge
		v1 := 1
	else
		v1 := 0
	end
;

: goto-charge
	draw-hit-zone

	gamestate := STATE_CHARGE
	setstate
;

: exit-taptap
	v0 := 0

	loop
		load-note

		remove-note
		v0 += 1
		while v0 != 10
	again
;

## NOTE DRAWING ##############################################################

# sets i to the sprite associated with the current note
: get-note-sprite
	gettype
	# layer 1
	if type == NOTE_STD_1 	then jump draw-note-1
	if type == NOTE_STD_Q_1 then jump draw-note-1

	# layer 2
	if type == NOTE_STD_2 	then jump draw-note-2
	if type == NOTE_STD_Q_2 then jump draw-note-2

	# split
	if type == NOTE_SPLIT_1   then jump draw-note-3
	if type == NOTE_SPLIT_2   then jump draw-note-3
	if type == NOTE_SPLIT_Q_1 then jump draw-note-3
	if type == NOTE_SPLIT_Q_2 then jump draw-note-3
;

: draw-note-1
	plane 1
	jump build-std-note-sprite
;

: draw-note-2
	plane 2
	jump build-std-note-sprite
;

: draw-note-3
	plane 3
	build-double-note-sprite
;

# build a standard note sprite
: build-std-note-sprite
	getinput
	if input == 0x0 then i := note-simple-question
	if input == 0xB then i := note-simple-question
	if input == 0x7 then i := note-simple-a
	if input == 0x8 then i := note-simple-s
	if input == 0x9 then i := note-simple-d
	if input == 0xE then i := note-simple-f
	if input == 0x4 then i := note-simple-q
	if input == 0x5 then i := note-simple-w
	if input == 0x6 then i := note-simple-e
	if input == 0xD then i := note-simple-r
	sprite px v2 8
;

: build-double-note-sprite
	getinput
	if input == 0x0 then i := note-double-question
	if input == 0xB then i := note-double-question
	if input == 0x7 then i := note-double-a
	if input == 0x8 then i := note-double-s
	if input == 0x9 then i := note-double-d
	if input == 0xE then i := note-double-f
	if input == 0x4 then i := note-double-q
	if input == 0x5 then i := note-double-w
	if input == 0x6 then i := note-double-e
	if input == 0xD then i := note-double-r
	sprite px v2 8
;

## NOTE BEHAVIORS ############################################################

# entry point to behavior table
: do-behavior
	v2 := v0

	gettype
	v0 := v1
	v0 <<= v0
	v0 += 2
	jump0 jump-behaviors
;

:macro is-oppo-note A {
	getinput
	A := 0
	if input == 0x4 then A := 1
	if input == 0x5 then A := 1
	if input == 0x6 then A := 1
	if input == 0xD then A := 1
	if input == 0xB then A := 1
}

: jump-behaviors
	return 
	return					# type 0 does nothing
	jump std-behavior 				# standard note
	jump std-behavior
	jump std-question-behavior
	jump std-question-behavior
	jump split-behavior
	jump split-behavior
	jump split-question-behavior
	jump split-question-behavior
;

# A standard note on its merry way
: std-behavior
	v0 := v2		# restore the counter

	# kill when off-screen
	is-oppo-note v2

	if v2 == 0 begin if px >= 68 then note-self-kill end
	if v2 == 1 begin if px <= 54 then note-self-kill end
;

# A standard note that doesn't reveal its input until the last moment
: std-question-behavior
	v0 := v2		# restore the counter

	is-oppo-note v3
	if v3 == 0 then v3 := DECISION_X
	if v3 == 1 then v3 := DECISION_X_RIGHT

	if px != v3 then return

	# convert to standard note
	is-oppo-note v3
	if v3 == 0 then random-base-input
	if v3 == 1 then random-flipped-input
	setinput

	gettype
	type += -2
	settype

	v0 := v2
;

# A note that doesn't show its lane until the last moment
: split-behavior
	v0 := v2

	is-oppo-note v3
	if v3 == 0 then v3 := DECISION_X
	if v3 == 1 then v3 := DECISION_X_RIGHT

	if px != v3 then return

	gettype
	type += -4
	settype

	py := random 1

	v0 := v2
;

# A note that doesn't show its lane or input until the last moment
: split-question-behavior
	v0 := v2

	is-oppo-note v3
	if v3 == 0 then v3 := DECISION_X
	if v3 == 1 then v3 := DECISION_X_RIGHT

	if px != v3 then return

	is-oppo-note v3
	if v3 == 0 then random-base-input
	if v3 == 1 then random-flipped-input
	setinput

	gettype
	type += -6

	if type == NOTE_STD_1 then py := 0
	if type == NOTE_STD_2 then py := 1

	settype

	v0 := v2
;

: note-self-kill
	type := NOTE_NONE
	settype
;

## FACTORY BEHAVIORS #########################################################

# check whether to spawn a new note
: note-factory
	spawn-timer += 1
	if spawn-timer == next-spawn then generate-new-note
;

# generate details of a new note
: generate-new-note
	direction := 0
	getopponent
	if opponent > 4 then direction := 1
	if opponent > 9 then direction := 2

	if direction == 0 then px := 0
	if direction == 1 then px := 119

	goto-factory-jump-table

	if direction == 2 begin
		is-oppo-note direction
		if direction == 1 then px := 119
		if direction == 0 then px := 0
	end

	spawn-note
	set-spawn-timer

	charge := 1
	add-npc-charge
;

: set-spawn-timer
	spawn-timer := 0
	next-spawn := random 20
	next-spawn += 10
;

: generate-standard-note
	type := random 1
	type += 1
	settype

	py := random 7

	# 5 of 8 times spawn on correct lane
	if py < 3 begin
		gettype
		py := type
		py += -1
		ve := 1
		py ^= ve
	else
		gettype
		py := type
		py += -1
	end

	if direction == 0 then random-base-input
	if direction == 1 then random-flipped-input
	if direction == 2 then random-combined-input
	setinput

	charge := 3
;

: generate-question-note
	type := random 1
	py := type 	# don't spawn questions on wrong lane
	type += 3
	settype

	if direction == 0 then input := 0x0
	if direction == 1 then input := 0xB
	if direction == 2 begin
		direction := random 1
		if direction == 0 then input := 0x0
		if direction == 1 then input := 0xB
	end
	setinput

	charge := 3
;

: generate-split-note
	type := random 1
	type += 5
	settype

	if direction == 0 then random-base-input
	if direction == 1 then random-flipped-input
	if direction == 2 then random-combined-input
	setinput

	py := 2

	charge := 3
;

: generate-split-question-note
	type := random 1
	type += 7
	settype

	if direction == 0 then input := 0x0
	if direction == 1 then input := 0xB
	if direction == 2 begin
		direction := random 1
		if direction == 0 then input := 0x0
		if direction == 1 then input := 0xB
	end
	setinput

	py := 2

	charge := 3
;

: goto-factory-jump-table
	getopponent
	v0 := opponent
	v0 <<= v0
	jump0 jump-tables
;

: jump-tables
	jump level1
	jump level2
	jump level3
	jump level4
	jump level5
	jump level1
	jump level2
	jump level3
	jump level4
	jump level5
	jump level1
	jump level2
	jump level3
	jump level4
	jump level5
	jump level6
;

: level1
	jump jump-level1-table	
;

: jump-level1-table
	jump generate-standard-note
;

: level2
	v0 := random 1
	v0 <<= v0
	jump0 jump-level2-table
;

: jump-level2-table
	jump generate-standard-note
	jump generate-question-note
;

: level3
	v0 := random 15
	v0 <<= v0
	jump0 jump-level3-table
;

: jump-level3-table
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
;

: level4
	v0 := random 15
	v0 <<= v0
	jump0 jump-level4-table
;

: jump-level4-table
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
;

: level5
	v0 := random 15
	v0 <<= v0
	jump0 jump-level5-table
;

: jump-level5-table
	jump generate-standard-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
;

: level6
	v0 := random 15
	v0 <<= v0
	jump0 jump-level6-table
;

: jump-level6-table
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
	jump generate-split-question-note
;

## CHARGE LOOP ###############################################################

: charge-state
	pxl := 0
	pxr := PLAYER_X
	ticker := 0
	fall-step := 0

	draw-npc

	loop
		getstate
		if gamestate == STATE_RESULT then return

		vf := 20
		delay := vf

		loop
			vf := delay
			if vf != 0 then
		again

		charge-loop
	again
;

: charge-loop
	draw-npc
	if pxl > 15 then draw-player

	if pxl == JOUST_X then resolve-hit

	# track ticks since the collision for animation purposes
	getstate
	if gamestate != STATE_CHARGE then fall-step += 1

	pxl += 3
	draw-npc

	if pxl <= 18 then return

	pxr += -3
	draw-player

	if pxl >= 110 then goto-result
;

: resolve-hit
	if pc-charge >= npc-charge then gamestate := STATE_NPC_LOSE
	if pc-charge < npc-charge then gamestate := STATE_PC_LOSE
	setstate
;

: goto-result
	gamestate := STATE_RESULT
	setstate
;

## RESULT SCREEN #############################################################

: result-state
	x := 10
	y := 5

	if pc-charge >= npc-charge then jump win-result
	if pc-charge < npc-charge  then jump lose-result
;

: win-result
	draw-you-win

	if pc-charge == npc-charge 	then v0 := 0
	if pc-charge > 64			then v0 := 1
	if pc-charge > 72			then v0 := 2
	if pc-charge > 80			then v0 := 3

	getopponent
	i := level-scores
	i += opponent
	save v0 - v0

	x := 40
	y := 20
	draw-stars

	wait-for-continue

	getopponent
	v1 += 1
	setopponent

	gamestate := STATE_OPPONENT
	setstate
;

: lose-result
	draw-you-lose

	wait-for-continue

	gamestate := STATE_TITLE
	setstate
;

: wait-for-continue
	loop
		v0 := key
		if v0 == 0xA then return
	again
;

: reset-state
	pc-charge := 0
	npc-charge := 0
;

: draw-you-lose
	j := 64
	plane 3
	i := youlosewin-label
	sprite x y 0

	x += 15
	i += j
	sprite x y 0

	x += 15
	i += j
	sprite x y 0
;

: draw-you-win
	j := 64
	plane 3
	i := youlosewin-label
	sprite x y 0

	x += 14
	i += j
	i += j
	i += j
	sprite x y 0

	x += 16
	i += j
	sprite x y 0
;

## TITLE SCREEN ##############################################################

: title-screen
	lores

	x := 1
	y := 7
	draw-chipjoust

	v0 := key
	gamestate := STATE_OPPONENT
	setstate

	opponent := 0
	setopponent
;

: draw-chipjoust
	v0 := 64
	plane 3
	i := long chipjoust-title
	sprite x y 0

	x += 15
	i += v0 #:= long chipjoustIP
	sprite x y 0

	x += 15
	i += v0 #:= long chipjoustJO
	sprite x y 0

	x += 16
	i += v0 #:= long chipjoustUST
	sprite x y 0
;

## OPPONENT SCREEN ###########################################################

: opponent-screen
	hires

	draw-preview-npc

	x := 35
	y := 42
	draw-level-label

	va := 79
	vb := 42
	draw-level-number

	v0 := key
	gamestate := STATE_TAPTAP
	setstate

	reset-state
;

: draw-level-label
	v0 := 11
	i := long level-label
	plane 1
	sprite x y 10
	plane 2
	sprite x y 10

	x += 8
	i += v0 #:= long levelE
	plane 1
	sprite x y 10
	plane 2
	sprite x y 10

	x += 8
	i += v0 #:= long levelV
	plane 1
	sprite x y 10
	plane 2
	sprite x y 10

	x += 8
	i := long level-label
	i += v0 #:= long levelE
	plane 1
	sprite x y 10
	plane 2
	sprite x y 10

	x += 8
	i := long level-label
	plane 1
	sprite x y 10
	plane 2
	sprite x y 10
; 

: draw-level-number
	getopponent
	opponent += 1

	i := bcd-num
	bcd opponent
	load v7 - v9

	if v7 != 0 begin
		v1 := v7
		gothicnum
		plane 3
		sprite va vb 15

		va += 8
	end

	if v8 != 0 begin
		v1 := v8
		gothicnum
		plane 3
		sprite va vb 15

		va += 8
	end

	#if v9 != 0 begin
		v1 := v9
		gothicnum
		plane 3
		sprite va vb 15

		va += 8
	#end
;

## DRAW ROUTINES #############################################################
: draw-ground
	vc := 0
	vd := 49
	i := ground

	loop
		plane 1
		sprite vc vd 13
		plane 2
		sprite vc vd 13
		
		vc += 8
		while vc != 128
	again

	draw-hit-zone	

	i := fill-bar
	vc := 63
	
	vd := 61
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

	vc += 1
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

;

: draw-hit-zone
	i := hit-zone

	vc := DRAW_HIT_SPOT_MIN
	vd := 1
	plane 1
	sprite vc vd 10

	vc := DRAW_HIT_SPOT_MIN
	vd := 11
	plane 2
	sprite vc vd 10
;

: draw-player
	# X depends on the state
	getstate
	if gamestate >= STATE_CHARGE then x := pxr
	if gamestate == STATE_TAPTAP then x := PLAYER_X

	y := CHARACTER_Y

	plane 1
	i := hors
	sprite x y 0

	draw-pc-knight	
;

: draw-pc-knight
	getstate
	if gamestate == STATE_TAPTAP then jump draw-pc-knight-mounted
	if gamestate == STATE_CHARGE then jump draw-pc-knight-mounted
	if gamestate == STATE_NPC_LOSE then jump draw-pc-knight-mounted

	draw-pc-knight-dismounted
;

: draw-pc-knight-mounted
	i := mans
	x += 7
	plane 2
	sprite x y 12

	plane 1
	i := hats
	sprite x y 1

	i := lance
	x += -16
	y += 5
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-pc-knight-dismounted
	plane 1

	# initial start position
	x := 75
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x += fall-step
	x += fall-step
	y += fall-step

	plane 2
	if fall-step >= 10 then jump draw-pc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-pc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-pc-knight-dismounted-1
;

: draw-npc
	x := pxl
	y := CHARACTER_Y

	plane 2
	i := hors-reverse
	sprite x y 0

	draw-npc-knight
;

: draw-preview-npc
	x := 54
	y := 19

	plane 2
	i := hors-reverse
	sprite x y 0

	draw-npc-knight
;

: draw-npc-knight
	getstate
	if gamestate == STATE_OPPONENT 	then jump draw-npc-knight-mounted
	if gamestate == STATE_TAPTAP 	then jump draw-npc-knight-mounted
	if gamestate == STATE_CHARGE 	then jump draw-npc-knight-mounted
	if gamestate == STATE_PC_LOSE 	then jump draw-npc-knight-mounted

	draw-npc-knight-dismounted
;

: draw-npc-knight-mounted
	i := mans-reverse
	x += 5
	plane 1
	sprite x y 12

	getstate
	if gamestate != STATE_OPPONENT then jump draw-reverse-lance
	draw-reverse-lance-up
;

: draw-reverse-lance
	i := lance-reverse
	x += 4
	y += 4
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-reverse-lance-up
	i := lance-reverse-up
	x += 3
	y += -10
	plane 3
	sprite x y 15
;

: draw-npc-knight-dismounted
	plane 1

	# initial start position
	x := JOUST_X
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x -= fall-step
	x -= fall-step
	y += fall-step

	if fall-step >= 10 then jump draw-npc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-npc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-npc-knight-dismounted-1
;

: draw-pc-knight-dismounted-1
	i := mans-hit-1
	sprite x y 12
;

: draw-pc-knight-dismounted-2
	v0 := 12
	i := mans-hit-1
	i += v0
	sprite x y 12
;

: draw-pc-knight-dismounted-3
	v0 := 12
	i := mans-hit-1
	i += v0
	i += v0
	sprite x y 12
;

: draw-npc-knight-dismounted-1
	i := mans-reverse-hit-1
	sprite x y 12
;

: draw-npc-knight-dismounted-2
	v0 := 12
	i := mans-reverse-hit-1
	i += v0
	sprite x y 12
;

: draw-npc-knight-dismounted-3
	v0 := 12
	i := mans-reverse-hit-1
	i += v0
	i += v0
	sprite x y 12
;

: draw-npc-charge-meter
	x := npc-charge
	y := 62
	v3 := x
	v3 += charge

	plane NPC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != v3
	again
;

: draw-pc-charge-meter
	x := pc-charge
	y := 127
	x =- y
	x += 1
	v3 := x
	x -= charge
	y := 62

	plane PC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != v3
	again
;

## INPUT TABLES ##############################################################

# set a random input value from the basic input table
: random-base-input
	v0 := random 0b11
	v0 <<= v0
	v0 <<= v0
	jump0 jump-basic-input
;

: random-flipped-input
	v0 := random 0b11
	v0 <<= v0
	v0 <<= v0
	jump0 jump-flipped-input
;

: random-combined-input
	v0 := random 0b1
	if v0 == 1 then jump random-base-input
	random-flipped-input
;

# basic input jump table
: jump-basic-input
	input := 0x7 return
	input := 0x8 return
	input := 0x9 return
	input := 0xE return
;

: jump-flipped-input
	input := 0x4 return
	input := 0x5 return
	input := 0x6 return
	input := 0xD return
;

: random-question-input
	v0 := random 0b111
	v0 <<= v0
	v0 <<= v0
	jump0 jump-question-input
;

: random-question-flipped-input
	v0 := random 0b111
	v0 <<= v0
	v0 <<= v0
	jump0 jump-question-flipped-input
;

: random-question-combined-input
	v0 := random 0b1
	if v0 == 1 then jump random-question-input
	random-question-flipped-input
;

# input with question tile jump table
: jump-question-input
	input := 0x0 return
	input := 0x0 return
	input := 0x7 return
	input := 0x7 return
	input := 0x8 return
	input := 0x8 return
	input := 0x9 return
	input := 0xE return
;

# input with question tile jump table
: jump-question-flipped-input
	input := 0xB return
	input := 0xB return
	input := 0x4 return
	input := 0x4 return
	input := 0x5 return
	input := 0x5 return
	input := 0x6 return
	input := 0xD return
;

## DRAWING ###################################################################

# draw a group of stars starting at x,y
# v0 is how many to fill
: draw-stars
	vd := 0

	loop
		i := long star-sprite
		vc := 32
		if vd < v0 then i += vc

		plane 2
		sprite x y 0
		x += 16
		vd += 1

		while vd != 3
	again
;

## SPRITES ###################################################################
: mans
0x60 0xC0 0xC0 0x40 0x60 0xE0 0xE0 0x60 0x40 0x40 0x40 0x40

: mans-hit-1
0x00 0x0C 0x0E 0x06 0x03 0x0F 0x03 0x1F 0x06 0x08 0x08 0x00 # 1
0x00 0x06 0x0E 0x2C 0x14 0x0C 0x7E 0x98 0x20 0x40 0x00 0x00 # 2
0x00 0x20 0x73 0xFF 0x04 0x08 0x00 0x00 0x00 0x00 0x00 0x00 # 3

: mans-reverse
0xE0 0x60 0x60 0x40 0xC0 0xE0 0xE0 0xC0 0x40 0x40 0x40 0x40

: mans-reverse-hit-1
0x00 0x30 0x70 0x60 0xC0 0xF0 0xC0 0xF8 0x60 0x10 0x10 0x00 # 1
0x00 0x60 0x70 0x34 0x28 0x30 0x3E 0x19 0x04 0x02 0x00 0x00 # 2
0x00 0x04 0xCE 0xFF 0x20 0x10 0x00 0x00 0x00 0x00 0x00 0x00 # 3

: hats
0x60

: lance
0x00 0x07 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: lance-reverse
0xE0 0x00 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: lance-reverse-up
0x40 0x40 0x40 0x40 0x40 0x40 0x40 0x40 
0x40 0x40 0x40 0x40 0xC0 0xC0 0xC0 0x40 
0x40 0x40 0x40 0x40 0x40 0x40 0x40 0x40 
0x40 0x40 0x40 0xC0 0xC0 0xC0

: hors
0x00 0x00 0x60 0x00 0xF0 0x00 0xF0 0x00 
0xF8 0x00 0xD8 0x00 0x1C 0x00 0x1F 0x1C 
0x3F 0x7C 0x3F 0x7C 0x3F 0x7C 0x27 0x1C 
0x24 0x1C 0x24 0x14 0x24 0x14 0x24 0x14  

: hors-reverse
0x00 0x00 0x00 0x0C 0x00 0x1E 0x00 0x3E 
0x00 0x3E 0x00 0x76 0x38 0xF0 0x79 0xF0 
0x7D 0xF8 0x7D 0xF8 0x7D 0xF8 0x59 0xC8 
0x58 0x48 0x50 0x48 0x50 0x48 0x50 0x48 

: ground
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 
0xFF 0xFF 0xFF 0xFF 0xFF

: gate
0xFF 0xFF 0x11 0x11 0x11 0x11 0x11 0xFF

: fill-bar 0x80 0x80
: hit-zone 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8

: note-simple-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-simple-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-simple-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-simple-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-simple-question 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

: note-simple-q 0x7E 0xE7 0xDB 0xDB 0xE3 0xFB 0xFF 0x7E
: note-simple-w 0x7E 0xFF 0xDD 0xD5 0xD5 0xC1 0xFF 0x7E
: note-simple-e 0x7E 0xFF 0xC3 0xD3 0xCF 0xC3 0xFF 0x7E
: note-simple-r 0x7E 0xFF 0xC7 0xDB 0xD7 0xDB 0xFF 0x7E

: note-double-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E 0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-double-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-double-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-double-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-double-question 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

: note-double-q 0x7E 0xE7 0xDB 0xDB 0xE3 0xFB 0xFF 0x7E 0x7E 0xE7 0xDB 0xDB 0xE3 0xFB 0xFF 0x7E
: note-double-w 0x7E 0xFF 0xDD 0xD5 0xD5 0xC1 0xFF 0x7E 0x7E 0xFF 0xDD 0xD5 0xD5 0xC1 0xFF 0x7E
: note-double-e 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xC3 0x7E 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xC3 0x7E
: note-double-r 0x7E 0xFF 0xC7 0xDB 0xD7 0xDB 0xFF 0x7E 0x7E 0xFF 0xC7 0xDB 0xD7 0xDB 0xFF 0x7E

: youlosewin-label
0x00 0x00 0xCC 0x30 0x66 0x48 0x67 0x4C # YO
0x67 0x4C 0x27 0x4C 0x1F 0x3C 0x0F 0x18 
0x07 0x00 0x27 0x00 0x3F 0x00 0x1E 0x00 
0x0C 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0xCC 0x30 0x66 0x48 0x66 0x48 
0x66 0x48 0x26 0x48 0x1E 0x30 0x06 0x00 
0x06 0x00 0x26 0x00 0x3C 0x00 0x18 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x00 0x81 0x8C 0x49 0x92 0x4D 0x93 # ULO
0x4D 0x93 0x4D 0x93 0x3D 0x8F 0x19 0x86 
0x01 0xC0 0x01 0xFC 0x00 0xFE 0x00 0x7C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x00 0x81 0x8C 0x49 0x92 0x49 0x92 
0x49 0x92 0x49 0x92 0x31 0x8C 0x01 0x80 
0x01 0xC0 0x01 0xFC 0x00 0xF8 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x31 0xC0 0x49 0x20 0x25 0x00 # SE
0x11 0x80 0x49 0x20 0x3D 0xF0 0x18 0xE0 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x31 0xC0 0x49 0x20 0x21 0x00 
0x11 0x80 0x49 0x20 0x31 0xC0 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x0C 0x81 0x86 0x49 0x87 0x4D 0x87 # UW
0x4D 0xA7 0x4D 0x97 0x3D 0x97 0x19 0xD7 
0x01 0xFF 0x00 0xFF 0x00 0x7E 0x00 0x3C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x0C 0x81 0x86 0x49 0x86 0x49 0x86 
0x49 0xA6 0x49 0x96 0x31 0x96 0x01 0xD6 
0x01 0xFE 0x00 0xFC 0x00 0x78 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x24 0x00 0x13 0x80 0x22 0x40 # IN
0x32 0x60 0x32 0x60 0x72 0x60 0x24 0xE0 
0x00 0x40 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x24 0x00 0x03 0x80 0x22 0x40 
0x22 0x40 0x22 0x40 0x42 0x40 0x04 0x80 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: chipjoust-title
0x3C 0x00 0x7E 0x40 0xF3 0x28 0xF1 0x34 # CH
0xF0 0x32 0xF0 0x33 0xF0 0x33 0xF0 0x33 
0xF1 0x97 0xF3 0x82 0x7F 0x80 0x3F 0x00 
0x1E 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x3C 0x00 0x7E 0x40 0xE3 0x28 0xA1 0x34 
0xA0 0x22 0xA0 0x22 0xA0 0x22 0xA0 0x22 
0xA1 0x04 0xE3 0x00 0x7E 0x00 0x3C 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x04 0x00 0x53 0x80 0x23 0xC0 # IP
0x33 0x60 0x33 0x60 0x33 0xE0 0x33 0xE0 
0x73 0xC0 0x2B 0x00 0x01 0x80 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x04 0x00 0x53 0x80 0x22 0x40 
0x22 0x40 0x22 0x40 0x23 0xC0 0x23 0x80 
0x52 0x00 0x02 0x00 0x01 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x3E 0x80 0x7F 0x9C 0x77 0xBE 0x07 0xBF # JO
0x07 0xB3 0x07 0xB7 0x07 0x9F 0x07 0x8E 
0x87 0x80 0x67 0x80 0x3F 0x00 0x1E 0x00 
0x0C 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x3E 0x80 0x65 0x1C 0x45 0x36 0x05 0x22 
0x05 0x22 0x05 0x36 0x05 0x1C 0x05 0x00 
0x85 0x00 0x66 0x00 0x3C 0x00 0x18 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x81 0xC4 0x52 0x0E 0x59 0x87 # UST
0x58 0x46 0x5A 0x66 0x39 0xEE 0x10 0xC4 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x81 0xC4 0x52 0x0E 0x51 0x84 
0x50 0x44 0x52 0x44 0x21 0x88 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: level-label 	
0xB0 0x50 0x50 0x50 0x50 0x50 0x50 0x52 0x5E 0x3E 0x00 # L
0x2C 0xF2 0x50 0x50 0x58 0x50 0x50 0x50 0x52 0xBE 0x42 # E
0x81 0x46 0x4A 0x4A 0x4A 0x4A 0x4A 0x4C 0x78 0x40 0x80 # V

: star-sprite
0x01 0x00 0x01 0x00 0x03 0x80 0x02 0x80 # empty
0x04 0x40 0x04 0x40 0xF8 0x3E 0x40 0x04 
0x20 0x08 0x10 0x10 0x08 0x20 0x09 0x20 
0x12 0x90 0x24 0x48 0x78 0x3C 0x00 0x00  
0x01 0x00 0x01 0x00 0x03 0x80 0x03 0x80 # filled
0x07 0xC0 0x07 0xC0 0xFF 0xFE 0x7F 0xFC 
0x3F 0xF8 0x1F 0xF0 0x0F 0xE0 0x0F 0xE0 
0x1E 0xF0 0x3C 0x78 0x78 0x3C 0x00 0x00 