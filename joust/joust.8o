# Structure for individual notes
:alias type			v1	# type of note
:alias input		v1	# key code note looks for
:alias details		va	# type of node (0xF0) and key code (0x0F)
:alias px			vb	# x position of the note
:alias py 			vc	# y position of the note (lane, not actual position)
:alias charge 		vd	# charge granted by the note
#:alias ???			vc 
#:alias ???			vd 
#:alias ???			ve 

:const MASK_TYPE	0b11110000
:const MASK_INPUT	0b00001111

# Structure for charging
:alias pxl			v9	# position of the left horse
:alias pxr			va	# position of the right horse
:alias ticker		vb

# Constant world state
:alias state 		v4
:alias pc-charge	v5
:alias npc-charge	v6

# taptap world state
:alias spawn-timer	v7
:alias next-spawn	v8

# charge world state
:alias fall-ticks	v7	# ticks since the collision
:alias fall-step	v8	# step of the fall

:alias j v0
:alias x v1
:alias y v2

:const STATE_TITLE		0
:const STATE_TAPTAP		1
:const STATE_CHARGE		2
:const STATE_NPC_LOSE	3
:const STATE_PC_LOSE 	4
:const STATE_RESULT	 	5

:const NOTE_NONE		0	# not an active note
:const NOTE_STD_1		1	# standard block note for layer 1
:const NOTE_STD_2		2	# standard block note for layer 2
:const NOTE_STD_Q_1		3	# note hides input until last moment
:const NOTE_STD_Q_2		4
:const NOTE_SPLIT_1		5	# a note that splits lanes before it switches to one
:const NOTE_SPLIT_2		6
:const NOTE_SPLIT_Q_1	7	# split lanes and hide input
:const NOTE_SPLIT_Q_2	8

:const PC_PLANE		2
:const NPC_PLANE	1

:const DRAW_HIT_SPOT_MIN	62
:const DRAW_HIT_SPOT_MAX 	67
:const HIT_SPOT_MIN 		55
:const HIT_SPOT_MAX 		67
:const DECISION_X			40

:const PLAYER_X				96
:const CHARACTER_Y			33
:const JOUST_X				48	# x position of npc at the collision point

: main
	hires
	state := STATE_TAPTAP

	loop
		if state == STATE_TAPTAP	then game-loop
		if state == STATE_CHARGE	then charge-state
		if state == STATE_NPC_LOSE	then charge-state
		if state == STATE_PC_LOSE	then charge-state
		if state == STATE_RESULT	then result-state
	again
;

## DATAFYING #################################################################
: gettype
	v1 := details
	v1 >>= v1
	v1 >>= v1
	v1 >>= v1
	v1 >>= v1
;

: settype
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1

	vf := MASK_INPUT
	details &= vf
	details += v1
;

: getinput
	v1 := MASK_INPUT
	v1 &= details
;

: setinput
	vf := MASK_TYPE
	details &= vf
	details += v1
;

## GAME LOOP #################################################################
: game-loop
	next-spawn := 30

	draw-ground
	setup-player

	loop
		if state != STATE_TAPTAP then jump exit-taptap

		vf := 2
		delay := vf

		loop
			vf := delay
			if vf != 0 then
		again

		loop-notes
		read-input
		note-factory
	again
;

: setup-player
	draw-player
;

# look for keyboard input
: read-input
	if state != STATE_TAPTAP then return

	v3 := 0x7
	if v3 key then jump process-input
	
	v3 := 0x8
	if v3 key then jump process-input

	v3 := 0x9
	if v3 key then jump process-input

	v3 := 0xE
	if v3 key then jump process-input
;

# if input made, go through notes to see if there is one in sweet spot,
# and determine if input is correct for it
: process-input
	v0 := 0

	loop
		load-note
		gettype

		if type != NOTE_NONE begin
			can-hit-note

			if v1 == 1 then jump hit-note
		end

		v0 += 1
		while v0 != 10
	again
;

# process result of hitting the current note
# v0 is the key that was hit
: hit-note
	gettype
	v1 += -1

	if v1 != py 		then jump process-bad-hit

	getinput
	if input != v3 		then jump process-bad-hit

	process-good-hit
;

# process hitting the note correctly
: process-good-hit
	load-note
	add-pc-charge
	remove-note
;

# process hitting the note poorly
: process-bad-hit
	load-note
	add-npc-charge
	
	if v1 == 0 then remove-note

	v0 := 10
	buzzer := v0
;

: remove-note
	gettype
	if type == NOTE_NONE then return

	draw-note

	type := 0
	settype
	save-note
;

# determines if the current note is in the hit zone, and saves result to v1
: can-hit-note
	v1 := 1
	if px < HIT_SPOT_MIN then v1 := 0
	if px > HIT_SPOT_MAX then v1 := 0
;

# loop through notes and call update on each
: loop-notes
	v0 := 0

	loop
		update-note
		v0 += 1
		while v0 != 10
	again
;

# draw and update an individual note
# this loads the note in memory, based on index counter v0 set by :loop-notes
: update-note
	load-note
	gettype

	if type == NOTE_NONE then return

	draw-note
	step-note
	draw-note
;

# convert v0 into memory offset and put in v1
: note-index-to-offset
	v1 := v0
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
;

# loads a note from memory
# v0 is index of the note to load
# uses v1 to store memory offset
: load-note
	note-index-to-offset
	i := notes
	i += v1
	load details - charge
;

# v0 is the index of the current note
# uses v1 to store memory offset
: save-note
	note-index-to-offset
	i := notes
	i += v1
	save details - charge
;

# step the note loaded into memory
: step-note
	gettype

	do-behavior

	px += 2
	save-note
;

# draws the note loaded into memory
: draw-note
	gettype
	if type == NOTE_NONE then return

	# lane
	if py == 0 then v2 := 2
	if py == 1 then v2 := 12
	if py == 2 then v2 := 7

	get-note-sprite
;

# saves a new note to the first empty note slot
# the data of the note should already be populated to the registers
: spawn-note
	draw-note

	# find empty memory
	i := notes

	loop
		load v1 - v1
		v1 >>= v1
		v1 >>= v1
		v1 >>= v1
		v1 >>= v1

		v0 := 8
		if v1 != NOTE_NONE then i += v0
		while v1 != NOTE_NONE
	again

	save details - charge
;

# add the charge of the current note to the pc charge
: add-pc-charge
	draw-pc-charge-meter
	pc-charge += charge

	check-charges
;

# add the charge of the current note to the npc charge
: add-npc-charge
	draw-npc-charge-meter
	npc-charge += charge

	check-charges
;

# look for when the charges meet
: check-charges
	v1 := pc-charge
	v1 += npc-charge

	if v1 >= 128 begin 
		goto-charge
		v1 := 1
	else
		v1 := 0
	end
;

: goto-charge
	draw-hit-zone
	state := STATE_CHARGE
;

: exit-taptap
	v0 := 0

	loop
		load-note

		remove-note
		v0 += 1
		while v0 != 10
	again
;

## NOTE DRAWING ##############################################################

# sets i to the sprite associated with the current note
: get-note-sprite
	gettype
	# layer 1
	if type == NOTE_STD_1 	then jump draw-note-1
	if type == NOTE_STD_Q_1 then jump draw-note-1

	# layer 2
	if type == NOTE_STD_2 	then jump draw-note-2
	if type == NOTE_STD_Q_2 then jump draw-note-2

	# split
	if type == NOTE_SPLIT_1   then jump draw-note-3
	if type == NOTE_SPLIT_2   then jump draw-note-3
	if type == NOTE_SPLIT_Q_1 then jump draw-note-3
	if type == NOTE_SPLIT_Q_2 then jump draw-note-3
;

: draw-note-1
	plane 1
	jump build-std-note-sprite
;

: draw-note-2
	plane 2
	jump build-std-note-sprite
;

: draw-note-3
	plane 3
	build-double-note-sprite
;

# build a standard note sprite
: build-std-note-sprite
	getinput
	if input == 0x0 then i := note-simple-q
	if input == 0x7 then i := note-simple-a
	if input == 0x8 then i := note-simple-s
	if input == 0x9 then i := note-simple-d
	if input == 0xE then i := note-simple-f
	sprite px v2 8
;

: build-double-note-sprite
	getinput
	if input == 0x0 then i := note-double-q
	if input == 0x7 then i := note-double-a
	if input == 0x8 then i := note-double-s
	if input == 0x9 then i := note-double-d
	if input == 0xE then i := note-double-f
	sprite px v2 8
;

## NOTE BEHAVIORS ############################################################

# entry point to behavior table
: do-behavior
	v2 := v0

	gettype
	v0 := v1
	v0 <<= v0
	v0 += 2
	jump0 jump-behaviors
;

: jump-behaviors
	return 
	return					# type 0 does nothing
	jump std-behavior 				# standard note
	jump std-behavior
	jump std-question-behavior
	jump std-question-behavior
	jump split-behavior
	jump split-behavior
	jump split-question-behavior
	jump split-question-behavior
;

# A standard note on its merry way
: std-behavior
	v0 := v2		# restore the counter

	# kill when off-screen
	if px >= 68 then note-self-kill
;

# A standard note that doesn't reveal its input until the last moment
: std-question-behavior
	v0 := v2		# restore the counter

	if px != DECISION_X then return

	# convert to standard note
	random-base-input
	setinput

	gettype
	type += -2
	settype

	v0 := v2		# restore the counter
;

# A note that doesn't show its lane until the last moment
: split-behavior
	v0 := v2

	if px != DECISION_X then return

	gettype
	type += -4
	settype

	py := random 1

	v0 := v2
;

# A note that doesn't show its lane or input until the last moment
: split-question-behavior
	v0 := v2

	if px != DECISION_X then return

	random-base-input
	setinput

	gettype
	type += -6

	if type == NOTE_STD_1 then py := 0
	if type == NOTE_STD_2 then py := 1

	settype

	v0 := v2
;

: note-self-kill
	type := NOTE_NONE
	settype
;

## FACTORY BEHAVIORS #########################################################

# check whether to spawn a new note
: note-factory
	if state != STATE_TAPTAP then return
	spawn-timer += 1
	if spawn-timer == next-spawn then generate-new-note
;

# generate details of a new note
: generate-new-note
	goto-factory-jump-table

	spawn-note
	set-spawn-timer

	charge := 1
	add-npc-charge
;

: set-spawn-timer
	spawn-timer := 0
	next-spawn := random 20
	next-spawn += 20
;

: goto-factory-jump-table
	v0 := random 15
	v0 <<= v0
	jump0 jump-standard
;

: jump-standard
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-standard-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-question-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-note
	jump generate-split-question-note
	jump generate-split-question-note
;

: generate-standard-note
	type := random 1
	type += 1
	settype

	random-base-input
	setinput

	px := 0
	py := random 1

	charge := 3
;

: generate-question-note
	type := random 1
	py := type 	# don't spawn questions on wrong lane
	type += 3
	settype

	input := 0x0
	setinput

	px := 0

	charge := 3
;

: generate-split-note
	type := random 1
	type += 5
	settype

	random-base-input
	setinput

	px := 0
	py := 2

	charge := 3
;

: generate-split-question-note
	type := random 1
	type += 7
	settype

	input := 0x0
	setinput

	px := 0
	py := 2

	charge := 3
;

## CHARGE LOOP ###############################################################

: charge-state
	pxl := 0
	pxr := PLAYER_X
	ticker := 0
	fall-step := 0

	draw-npc

	loop
		if state == STATE_RESULT then return

		vf := 20
		delay := vf

		loop
			vf := delay
			if vf != 0 then
		again

		charge-loop
	again
;

: charge-loop
	draw-npc
	if pxl > 15 then draw-player

	if pxl == JOUST_X then resolve-hit

	# track ticks since the collision for animation purposes
	if state != STATE_CHARGE then fall-step += 1

	pxl += 3
	draw-npc

	if pxl <= 18 then return

	pxr += -3
	draw-player

	if pxl >= 110 then goto-result
;

: resolve-hit
	if pc-charge >= npc-charge then state := STATE_NPC_LOSE
	if pc-charge < npc-charge then state := STATE_PC_LOSE
;

: goto-result
	state := STATE_RESULT
;

## RESULT SCREEN #############################################################

: result-state
	x := 10
	y := 5

	if pc-charge >= npc-charge then draw-you-win
	if pc-charge < npc-charge  then draw-you-lose

	v0 := key
;

## DRAW ROUTINES #############################################################

: draw-ground
	vc := 0
	vd := 49
	i := ground

	loop
		plane 1
		sprite vc vd 13
		plane 2
		sprite vc vd 13
		
		vc += 8
		while vc != 128
	again

	draw-hit-zone	

	i := fill-bar
	vc := 63
	
	vd := 61
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

	vc += 1
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

;

: draw-hit-zone
	i := hit-zone

	vc := DRAW_HIT_SPOT_MIN
	vd := 1
	plane 1
	sprite vc vd 10

	vc := DRAW_HIT_SPOT_MIN
	vd := 11
	plane 2
	sprite vc vd 10
;

: draw-player
	# X depends on the state
	if state == STATE_TAPTAP then x := PLAYER_X
	if state >= STATE_CHARGE then x := pxr

	y := CHARACTER_Y

	plane 1
	i := hors
	sprite x y 0

	draw-pc-knight	
;

: draw-pc-knight
	if state == STATE_TAPTAP then jump draw-pc-knight-mounted
	if state == STATE_CHARGE then jump draw-pc-knight-mounted
	if state == STATE_NPC_LOSE then jump draw-pc-knight-mounted

	draw-pc-knight-dismounted
;

: draw-pc-knight-mounted
	i := mans
	x += 7
	plane 2
	sprite x y 12

	plane 1
	i := hats
	sprite x y 1

	i := lance
	x += -16
	y += 5
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-pc-knight-dismounted
	plane 1

	# initial start position
	x := 75
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x += fall-step
	x += fall-step
	y += fall-step

	plane 2
	if fall-step >= 10 then jump draw-pc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-pc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-pc-knight-dismounted-1
;

: draw-npc
	x := pxl
	y := CHARACTER_Y

	plane 2
	i := hors-reverse
	sprite x y 0

	draw-npc-knight
;

: draw-npc-knight
	if state == STATE_TAPTAP then jump draw-npc-knight-mounted
	if state == STATE_CHARGE then jump draw-npc-knight-mounted
	if state == STATE_PC_LOSE then jump draw-npc-knight-mounted

	draw-npc-knight-dismounted
;

: draw-npc-knight-mounted
	i := mans-reverse
	x += 5
	plane 1
	sprite x y 12

	i := lance-reverse
	x += 4
	y += 4
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-npc-knight-dismounted
	plane 1

	# initial start position
	x := JOUST_X
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x -= fall-step
	x -= fall-step
	y += fall-step

	if fall-step >= 10 then jump draw-npc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-npc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-npc-knight-dismounted-1
;

: draw-pc-knight-dismounted-1
	i := mans-hit-1
	sprite x y 12
;

: draw-pc-knight-dismounted-2
	i := mans-hit-2
	sprite x y 12
;

: draw-pc-knight-dismounted-3
	i := mans-hit-3
	sprite x y 12
;

: draw-npc-knight-dismounted-1
	i := mans-reverse-hit-1
	sprite x y 12
;

: draw-npc-knight-dismounted-2
	i := mans-reverse-hit-2
	sprite x y 12
;

: draw-npc-knight-dismounted-3
	i := mans-reverse-hit-3
	sprite x y 12
;

: draw-npc-charge-meter
	x := npc-charge
	y := 62
	v3 := x
	v3 += charge

	plane NPC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != v3
	again
;

: draw-pc-charge-meter
	x := pc-charge
	y := 127
	x =- y
	x += 1
	v3 := x
	x -= charge
	y := 62

	plane PC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != v3
	again
;

## INPUT TABLES ##############################################################

# set a random input value from the basic input table
: random-base-input
	v0 := random 0b11
	v0 <<= v0
	v0 <<= v0
	jump0 jump-basic-input
;

# basic input jump table
: jump-basic-input
	input := 0x7 return
	input := 0x8 return
	input := 0x9 return
	input := 0xE return
;

: random-question-input
	v0 := random 0b111
	v0 <<= v0
	v0 <<= v0
	jump0 jump-basic-input
;

# input with question tile jump table
: jump-question-input
	input := 0x0 return
	input := 0x0 return
	input := 0x7 return
	input := 0x7 return
	input := 0x8 return
	input := 0x8 return
	input := 0x9 return
	input := 0xE return
;

## SPRITES ###################################################################
: mans
0x60 0xC0 0xC0 0x40 0x60 0xE0 0xE0 0x60 0x40 0x40 0x40 0x40

: mans-hit-1
0x00 0x0C 0x0E 0x06 0x03 0x0F 0x03 0x1F 0x06 0x08 0x08 0x00

: mans-hit-2
0x00 0x06 0x0E 0x2C 0x14 0x0C 0x7E 0x98 0x20 0x40 0x00 0x00

: mans-hit-3
0x00 0x20 0x73 0xFF 0x04 0x08 0x00 0x00 0x00 0x00 0x00 0x00

: mans-reverse
0xE0 0x60 0x60 0x40 0xC0 0xE0 0xE0 0xC0 0x40 0x40 0x40 0x40

: mans-reverse-hit-1
0x00 0x30 0x70 0x60 0xC0 0xF0 0xC0 0xF8 0x60 0x10 0x10 0x00

: mans-reverse-hit-2
0x00 0x60 0x70 0x34 0x28 0x30 0x3E 0x19 0x04 0x02 0x00 0x00

: mans-reverse-hit-3
0x00 0x04 0xCE 0xFF 0x20 0x10 0x00 0x00 0x00 0x00 0x00 0x00

: hats
0x60

: lance
0x00 0x07 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: lance-reverse
0xE0 0x00 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: hors
0x00 0x00 0x60 0x00 0xF0 0x00 0xF0 0x00 
0xF8 0x00 0xD8 0x00 0x1C 0x00 0x1F 0x1C 
0x3F 0x7C 0x3F 0x7C 0x3F 0x7C 0x27 0x1C 
0x24 0x1C 0x24 0x14 0x24 0x14 0x24 0x14  

: hors-reverse
0x00 0x00 0x00 0x0C 0x00 0x1E 0x00 0x3E 
0x00 0x3E 0x00 0x76 0x38 0xF0 0x79 0xF0 
0x7D 0xF8 0x7D 0xF8 0x7D 0xF8 0x59 0xC8 
0x58 0x48 0x50 0x48 0x50 0x48 0x50 0x48 

: ground
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 
0xFF 0xFF 0xFF 0xFF 0xFF

: gate
0xFF 0xFF 0x11 0x11 0x11 0x11 0x11 0xFF

: fill-bar 0x80 0x80
: hit-zone 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8

: note-simple-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-simple-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-simple-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-simple-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-simple-q 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

: note-double-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E 0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-double-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-double-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-double-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-double-q 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

: youloseYO
0x00 0x00 0xCC 0x30 0x66 0x48 0x67 0x4C 
0x67 0x4C 0x27 0x4C 0x1F 0x3C 0x0F 0x18 
0x07 0x00 0x27 0x00 0x3F 0x00 0x1E 0x00 
0x0C 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0xCC 0x30 0x66 0x48 0x66 0x48 
0x66 0x48 0x26 0x48 0x1E 0x30 0x06 0x00 
0x06 0x00 0x26 0x00 0x3C 0x00 0x18 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youloseULO
0x02 0x00 0x81 0x8C 0x49 0x92 0x4D 0x93 
0x4D 0x93 0x4D 0x93 0x3D 0x8F 0x19 0x86 
0x01 0xC0 0x01 0xFC 0x00 0xFE 0x00 0x7C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x00 0x81 0x8C 0x49 0x92 0x49 0x92 
0x49 0x92 0x49 0x92 0x31 0x8C 0x01 0x80 
0x01 0xC0 0x01 0xFC 0x00 0xF8 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youloseSE
0x00 0x00 0x31 0xC0 0x49 0x20 0x25 0x00 
0x11 0x80 0x49 0x20 0x3D 0xF0 0x18 0xE0 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x31 0xC0 0x49 0x20 0x21 0x00 
0x11 0x80 0x49 0x20 0x31 0xC0 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youwinUW
0x02 0x0C 0x81 0x86 0x49 0x87 0x4D 0x87 
0x4D 0xA7 0x4D 0x97 0x3D 0x97 0x19 0xD7 
0x01 0xFF 0x00 0xFF 0x00 0x7E 0x00 0x3C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x0C 0x81 0x86 0x49 0x86 0x49 0x86 
0x49 0xA6 0x49 0x96 0x31 0x96 0x01 0xD6 
0x01 0xFE 0x00 0xFC 0x00 0x78 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youwinIN
0x00 0x00 0x24 0x00 0x13 0x80 0x22 0x40 
0x32 0x60 0x32 0x60 0x72 0x60 0x24 0xE0 
0x00 0x40 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x24 0x00 0x03 0x80 0x22 0x40 
0x22 0x40 0x22 0x40 0x42 0x40 0x04 0x80 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: draw-you-lose
	plane 3
	i := youloseYO
	sprite x y 0

	x += 15
	i := youloseULO
	sprite x y 0

	x += 15
	i := youloseSE
	sprite x y 0
;

: draw-you-win
	plane 3
	i := youloseYO
	sprite x y 0

	x += 14
	i := youwinUW
	sprite x y 0

	x += 16
	i := youwinIN
	sprite x y 0
;

## MEMORY ####################################################################

# allocate in blocks of eight for easy multiplication
: notes
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0