# Structure for individual notes
:alias type			v9	# type of note
:alias input		va	# key code note looks for
:alias px			vb	# x position of the note
:alias py 			vc	# y position of the note (lane, not actual position)
:alias charge 		vd	# charge granted by the note
#:alias ???			vc 
#:alias ???			vd 
#:alias ???			ve 

# Structure for charging
:alias pxl			v9	# position of the left horse
:alias pxr			va	# position of the right horse
:alias ticker		vb

# Constant world state
:alias state 		v4
:alias pc-charge	v5
:alias npc-charge	v6

# taptap world state
:alias spawn-timer	v7
:alias next-spawn	v8

# charge world state
:alias fall-ticks	v7	# ticks since the collision
:alias fall-step	v8	# step of the fall

:alias j v0
:alias x v1
:alias y v2

:const STATE_TITLE		0
:const STATE_TAPTAP		1
:const STATE_CHARGE		2
:const STATE_NPC_LOSE	3
:const STATE_PC_LOSE 	4
:const STATE_RESULT	 	5

:const PC_PLANE		2
:const NPC_PLANE	1

:const DRAW_HIT_SPOT_MIN	105
:const DRAW_HIT_SPOT_MAX 	110
:const HIT_SPOT_MIN 		98
:const HIT_SPOT_MAX 		110

:const PLAYER_X				96
:const CHARACTER_Y			33
:const JOUST_X				48	# x position of npc at the collision point

: main
	hires
	state := STATE_TAPTAP

	loop
		if state == STATE_TAPTAP	then game-loop
		if state == STATE_CHARGE	then charge-state
		if state == STATE_NPC_LOSE	then charge-state
		if state == STATE_PC_LOSE	then charge-state
		if state == STATE_RESULT	then result-state
	again
;

## GAME LOOP #################################################################
: game-loop
	next-spawn := 30

	draw-ground
	setup-player

	#npc-charge := 120
	#pc-charge := 128

	loop
		if state != STATE_TAPTAP then jump exit-taptap

		loop-notes
		read-input
		note-factory
	again
;

: setup-player
	draw-player
;

# check whether to spawn a new note
: note-factory
	if state != STATE_TAPTAP then return
	spawn-timer += 1
	if spawn-timer == next-spawn then generate-new-note
;

# generate details of a new note
: generate-new-note
	type := random 1
	type += 1

	v0 := random 3
	if v0 == 0 then input := 0x7
	if v0 == 1 then input := 0x8
	if v0 == 2 then input := 0x9
	if v0 == 3 then input := 0xE

	px := 0
	py := random 1

	charge := 3

	spawn-note

	spawn-timer := 0
	next-spawn := random 20
	next-spawn += 20

	charge := 1
	add-npc-charge
;

# look for keyboard input
: read-input
	if state != STATE_TAPTAP then return

	v0 := 0x7
	if v0 key then jump process-input
	
	v0 := 0x8
	if v0 key then jump process-input

	v0 := 0x9
	if v0 key then jump process-input

	v0 := 0xE
	if v0 key then jump process-input
;

# if input made, go through notes to see if there is one in sweet spot,
# and determine if input is correct for it
: process-input
	i := notes
	v2 := 0
	v3 := 8

	loop
		load-note

		if type != 0 begin
			can-hit-note

			if v1 == 1 then jump hit-note
		end

		i += v3
		v2 += 1
		while v2 != 10
	again
;

# process result of hitting the current note
# v0 is the key that was hit
: hit-note
	v1 := type
	v1 += -1

	if v1 != py 		then jump process-bad-hit
	if input != v0 		then jump process-bad-hit

	process-good-hit
;

# process hitting the note correctly
: process-good-hit
	v3 := v2
	add-pc-charge
	remove-note
;

# process hitting the note poorly
: process-bad-hit
	v3 := v2
	add-npc-charge
	remove-note

	v0 := 10
	buzzer := v0
;

: exit-taptap
	v2 := 0

	loop
		i := notes
		v3 := v2
		v3 <<= v3
		v3 <<= v3
		v3 <<= v3
		i += v3

		load-note

		v3 := v2
		remove-note

		v2 += 1
		while v2 != 10
	again
;

: remove-note
	if type == 0 then return

	draw-note

	type := 0

	v3 <<= v3
	v3 <<= v3
	v3 <<= v3

	i := notes
	i += v3
	save type - charge
;

# determines if the current note is in the hit zone, and saves result to v1
: can-hit-note
	v1 := 1
	if px < HIT_SPOT_MIN then v1 := 0
	if px > HIT_SPOT_MAX then v1 := 0
;

# loop through notes and call update on each
: loop-notes
	v0 := 0

	loop
		update-note
		v0 += 1
		while v0 != 10
	again
;

# draw and update an individual note
# this loads the note in memory, based on index counter v0 set by :loop-notes
: update-note
	v1 := v0
	note-index-to-offset

	i := notes
	i += v1

	load-note

	if type == 0 then return

	draw-note
	step-note
	draw-note
;

: note-index-to-offset
	v1 <<= v1
	v1 <<= v1
	v1 <<= v1
;

# loads the note at the current i position
: load-note
	load type - charge
;

# v1 is the memory offset of the current note
: save-note
	i := notes
	i += v1
	save type - charge
;

# step the note loaded into memory
: step-note

	# kill when off-screen
	if px >= 125 then type := 0

	px += 1
	save-note
;

# draws the note loaded into memory
: draw-note
	if type == 0 then return

	get-note-sprite

	# lane
	if py == 0 then v2 := 2
	if py == 1 then v2 := 12
	if py == 2 then v2 := 22

	sprite px v2 8
;

# sets i to the sprite associated with the current note
: get-note-sprite
	# opponent
	if type == 1 begin
		plane 1
		if input == 0x0 then i := note-simple-q
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
		if input == 0xE then i := note-simple-f
	end

	# player
	if type == 2 begin
		plane 2
		if input == 0x0 then i := note-simple-q
		if input == 0x7 then i := note-simple-a
		if input == 0x8 then i := note-simple-s
		if input == 0x9 then i := note-simple-d
		if input == 0xE then i := note-simple-f
	end
;

# saves a new note to the first empty note slot
# the data of the note should already be populated to the registers
: spawn-note
	draw-note

	# find empty memory
	i := notes

	loop
		load v1 - v1

		v0 := 8
		if v1 != 0 then i += v0
		while v1 != 0
	again

	save type - charge
;

# add the charge of the current note to the pc charge
: add-pc-charge
	draw-pc-charge-meter
	pc-charge += charge

	check-charges
;

# add the charge of the current note to the npc charge
: add-npc-charge
	draw-npc-charge-meter
	npc-charge += charge

	check-charges
;

# look for when the charges meet
: check-charges
	v0 := pc-charge
	v0 += npc-charge

	if v0 >= 128 then goto-charge
;

: goto-charge
	draw-hit-zone
	state := STATE_CHARGE
;

## CHARGE LOOP ###############################################################

: charge-state
	pxl := 0
	pxr := PLAYER_X
	ticker := 0
	fall-step := 0

	draw-npc

	loop
		if state == STATE_RESULT then return

		vf := 20
		delay := vf

		loop
			vf := delay
			if vf != 0 then
		again

		charge-loop
	again
;

: charge-loop
	draw-npc
	if pxl > 15 then draw-player

	if pxl == JOUST_X then resolve-hit

	# track ticks since the collision for animation purposes
	if state != STATE_CHARGE then fall-step += 1

	pxl += 3
	draw-npc

	if pxl <= 18 then return

	pxr += -3
	draw-player

	if pxl >= 110 then goto-result
;

: resolve-hit
	if pc-charge >= npc-charge then state := STATE_NPC_LOSE
	if pc-charge < npc-charge then state := STATE_PC_LOSE
;

: goto-result
	state := STATE_RESULT
;

## RESULT SCREEN #############################################################

: result-state
	x := 10
	y := 5

	if pc-charge >= npc-charge then draw-you-win
	if pc-charge < npc-charge  then draw-you-lose

	v0 := key
;

## DRAW ROUTINES #############################################################

: draw-ground
	vc := 0
	vd := 49
	i := ground

	loop
		plane 1
		sprite vc vd 13
		plane 2
		sprite vc vd 13
		
		vc += 8
		while vc != 128
	again

	draw-hit-zone	

	i := fill-bar
	vc := 63
	
	vd := 61
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

	vc += 1
	plane 1
	sprite vc vd 1
	plane 2
	sprite vc vd 1

;

: draw-hit-zone
	i := hit-zone

	vc := DRAW_HIT_SPOT_MIN
	vd := 1
	plane 1
	sprite vc vd 10

	vc := DRAW_HIT_SPOT_MIN
	vd := 11
	plane 2
	sprite vc vd 10
;

: draw-player
	# X depends on the state
	if state == STATE_TAPTAP then x := PLAYER_X
	if state >= STATE_CHARGE then x := pxr

	y := CHARACTER_Y

	plane 1
	i := hors
	sprite x y 0

	draw-pc-knight	
;

: draw-pc-knight
	if state == STATE_TAPTAP then jump draw-pc-knight-mounted
	if state == STATE_CHARGE then jump draw-pc-knight-mounted
	if state == STATE_NPC_LOSE then jump draw-pc-knight-mounted

	draw-pc-knight-dismounted
;

: draw-pc-knight-mounted
	i := mans
	x += 7
	plane 2
	sprite x y 12

	plane 1
	i := hats
	sprite x y 1

	i := lance
	x += -16
	y += 5
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-pc-knight-dismounted
	plane 1

	# initial start position
	x := 75
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x += fall-step
	x += fall-step
	y += fall-step

	plane 2
	if fall-step >= 10 then jump draw-pc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-pc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-pc-knight-dismounted-1
;

: draw-npc
	x := pxl
	y := CHARACTER_Y

	plane 2
	i := hors-reverse
	sprite x y 0

	draw-npc-knight
;

: draw-npc-knight
	if state == STATE_TAPTAP then jump draw-npc-knight-mounted
	if state == STATE_CHARGE then jump draw-npc-knight-mounted
	if state == STATE_PC_LOSE then jump draw-npc-knight-mounted

	draw-npc-knight-dismounted
;

: draw-npc-knight-mounted
	i := mans-reverse
	x += 5
	plane 1
	sprite x y 12

	i := lance-reverse
	x += 4
	y += 4
	plane 1
	sprite x y 0
	plane 2
	sprite x y 0
;

: draw-npc-knight-dismounted
	plane 1

	# initial start position
	x := JOUST_X
	y := CHARACTER_Y

	if fall-step > 12 then fall-step := 12

	x -= fall-step
	x -= fall-step
	y += fall-step

	if fall-step >= 10 then jump draw-npc-knight-dismounted-3
	if fall-step >= 5 then 	jump draw-npc-knight-dismounted-2
	if fall-step >= 1 then 	jump draw-npc-knight-dismounted-1
;

: draw-pc-knight-dismounted-1
	i := mans-hit-1
	sprite x y 12
;

: draw-pc-knight-dismounted-2
	i := mans-hit-2
	sprite x y 12
;

: draw-pc-knight-dismounted-3
	i := mans-hit-3
	sprite x y 12
;

: draw-npc-knight-dismounted-1
	i := mans-reverse-hit-1
	sprite x y 12
;

: draw-npc-knight-dismounted-2
	i := mans-reverse-hit-2
	sprite x y 12
;

: draw-npc-knight-dismounted-3
	i := mans-reverse-hit-3
	sprite x y 12
;

: draw-npc-charge-meter
	x := npc-charge
	y := 62
	j := x
	j += charge

	plane NPC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != j
	again
;

: draw-pc-charge-meter
	x := pc-charge
	y := 127
	x =- y
	x += 1
	j := x
	x -= charge
	y := 62

	plane PC_PLANE
	i := fill-bar

	loop
		sprite x y 2
		x += 1
		while x != j
	again
;

## SPRITES ###################################################################
: mans
0x60 0xC0 0xC0 0x40 0x60 0xE0 0xE0 0x60 0x40 0x40 0x40 0x40

: mans-hit-1
0x00 0x0C 0x0E 0x06 0x03 0x0F 0x03 0x1F 0x06 0x08 0x08 0x00

: mans-hit-2
0x00 0x06 0x0E 0x2C 0x14 0x0C 0x7E 0x98 0x20 0x40 0x00 0x00

: mans-hit-3
0x00 0x20 0x73 0xFF 0x04 0x08 0x00 0x00 0x00 0x00 0x00 0x00

: mans-reverse
0xE0 0x60 0x60 0x40 0xC0 0xE0 0xE0 0xC0 0x40 0x40 0x40 0x40

: mans-reverse-hit-1
0x00 0x30 0x70 0x60 0xC0 0xF0 0xC0 0xF8 0x60 0x10 0x10 0x00

: mans-reverse-hit-2
0x00 0x60 0x70 0x34 0x28 0x30 0x3E 0x19 0x04 0x02 0x00 0x00

: mans-reverse-hit-3
0x00 0x04 0xCE 0xFF 0x20 0x10 0x00 0x00 0x00 0x00 0x00 0x00

: hats
0x60

: lance
0x00 0x07 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00

: lance-reverse
0xE0 0x00 0xFF 0xFF 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: hors
0x00 0x00 0x60 0x00 0xF0 0x00 0xF0 0x00 
0xF8 0x00 0xD8 0x00 0x1C 0x00 0x1F 0x1C 
0x3F 0x7C 0x3F 0x7C 0x3F 0x7C 0x27 0x1C 
0x24 0x1C 0x24 0x14 0x24 0x14 0x24 0x14  

: hors-reverse
0x00 0x00 0x00 0x0C 0x00 0x1E 0x00 0x3E 
0x00 0x3E 0x00 0x76 0x38 0xF0 0x79 0xF0 
0x7D 0xF8 0x7D 0xF8 0x7D 0xF8 0x59 0xC8 
0x58 0x48 0x50 0x48 0x50 0x48 0x50 0x48 

: ground
0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 
0xFF 0xFF 0xFF 0xFF 0xFF

: gate
0xFF 0xFF 0x11 0x11 0x11 0x11 0x11 0xFF

: fill-bar 0x80 0x80
: hit-zone 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8 0xF8

: note-simple-a	0x7E 0xE7 0xDB 0xC3 0xDB 0xDB 0xFF 0x7E
: note-simple-s 0x7E 0xE3 0xDF 0xC3 0xFB 0xC7 0xFF 0x7E
: note-simple-d 0x7E 0xC7 0xDB 0xDB 0xDB 0xC7 0xFF 0x7E
: note-simple-f 0x7E 0xC3 0xDF 0xC7 0xDF 0xDF 0xFF 0x7E
: note-simple-q 0x7E 0xC3 0xFB 0xFB 0xE7 0xFF 0xE7 0x7E

: youloseYO
0x00 0x00 0xCC 0x30 0x66 0x48 0x67 0x4C 
0x67 0x4C 0x27 0x4C 0x1F 0x3C 0x0F 0x18 
0x07 0x00 0x27 0x00 0x3F 0x00 0x1E 0x00 
0x0C 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0xCC 0x30 0x66 0x48 0x66 0x48 
0x66 0x48 0x26 0x48 0x1E 0x30 0x06 0x00 
0x06 0x00 0x26 0x00 0x3C 0x00 0x18 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youloseULO
0x02 0x00 0x81 0x8C 0x49 0x92 0x4D 0x93 
0x4D 0x93 0x4D 0x93 0x3D 0x8F 0x19 0x86 
0x01 0xC0 0x01 0xFC 0x00 0xFE 0x00 0x7C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x00 0x81 0x8C 0x49 0x92 0x49 0x92 
0x49 0x92 0x49 0x92 0x31 0x8C 0x01 0x80 
0x01 0xC0 0x01 0xFC 0x00 0xF8 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youloseSE
0x00 0x00 0x31 0xC0 0x49 0x20 0x25 0x00 
0x11 0x80 0x49 0x20 0x3D 0xF0 0x18 0xE0 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x31 0xC0 0x49 0x20 0x21 0x00 
0x11 0x80 0x49 0x20 0x31 0xC0 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youwinUW
0x02 0x0C 0x81 0x86 0x49 0x87 0x4D 0x87 
0x4D 0xA7 0x4D 0x97 0x3D 0x97 0x19 0xD7 
0x01 0xFF 0x00 0xFF 0x00 0x7E 0x00 0x3C 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x02 0x0C 0x81 0x86 0x49 0x86 0x49 0x86 
0x49 0xA6 0x49 0x96 0x31 0x96 0x01 0xD6 
0x01 0xFE 0x00 0xFC 0x00 0x78 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: youwinIN
0x00 0x00 0x24 0x00 0x13 0x80 0x22 0x40 
0x32 0x60 0x32 0x60 0x72 0x60 0x24 0xE0 
0x00 0x40 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x24 0x00 0x03 0x80 0x22 0x40 
0x22 0x40 0x22 0x40 0x42 0x40 0x04 0x80 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 

: draw-you-lose
	plane 3
	i := youloseYO
	sprite x y 0

	x += 15
	i := youloseULO
	sprite x y 0

	x += 15
	i := youloseSE
	sprite x y 0
;

: draw-you-win
	plane 3
	i := youloseYO
	sprite x y 0

	x += 14
	i := youwinUW
	sprite x y 0

	x += 16
	i := youwinIN
	sprite x y 0
;

## MEMORY ####################################################################

# allocate in blocks of eight for easy multiplication
: notes
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0
	0 0x0 0 0 0 0 0 0